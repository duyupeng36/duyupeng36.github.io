---
title: 操作字符串
createTime: 2025/11/18 21:18:18
permalink: /cppstudy/oi0y4kfm/
---

## C 风格字符串

在 [第五章 数组和循环#字符数组](./005-数组和循环.md#字符数组) 中介绍过 C 风格字符串，即以 `'\0'` 字符结尾的字符数组。标准库 `<cstring>` 中提供了许多函数，用于操作 C 风格字符串。下表列出来一些常用的函数

|函数原型| 描述 |
|:------|:-----|
|`char * strncpy(char *dest, const char *src, size_t n)`| 拷贝 `n` 个字符到 `dest` 字符数组中 |
|`size_t strlen(const char *src);`| 获取字符串中的字符数，不包括终止的空字符 `'\0'` |
|`char * strncat(char *dest, const char *src, size_t n);`| 追加`n` 个字符到 `dest` 字符数组的末尾 |
|`int strncmp(const char *s1, const char *s2, size_t n);`| 按编码比较 `s1` 和 `s2` 中的前 `n` 个字符 |
|`char *strchr(const char *str, int c)`| 查找字符 `c` 第一次出现在 `str` 中的位置 |
|`char *strrchr(const char *str, int c)`| 查找字符 `c` 最后一次出现在 `str` 中的位置 |
|`char *strstr(const char *str, const char *substr);`| 查找 `substr` 第一次出现在 `str` 中的位置|
|`char *strtok(char *str, const char *delim)`| 分割字符串 `str`，以 `delim` 中的字符作为分隔符 |

上表列出的所有函数都是在 `<cstring>` 头文件中定义的，使用时需要包含该头文件。

::: warning

`<cstring>` 只是 C 标准库 `<string.h>` 在 C++ 中的对应头文件，二者内容完全相同，但 C++ 版本的头文件将所有内容都放在了 `std` 命名空间中。

这些函数完全是基于空字符 `'\0'` 作为结尾的约定来操作字符串的。如果空字符被遗漏或者覆盖，这些函数就会操作字符串尾部后面的内存，直到某个位置遇到空字符为止。

这种行为可能会导致未定义行为，甚至程序崩溃。因此，在使用这些函数时，一定要确保字符串正确地以空字符结尾，并且目标字符数组有足够的空间来存储结果字符串和终止的空字符。

:::

## string 类型

C++ 标准库 `<string>` 模块中定义了 `string` 类型用于操作字符串，这是 C++ 中操作字符串的推荐方式。该类型要比 C 风格字符串更安全、更方便。

`std::string` 类型由一个类（准确的来说，是类模板）定义，所以它不是基本类型，而称为复合类型。**复合类型** 是组合了若干个数据项的类型，这些数据项最终都是根据基本数据类型定义的。

`string` 对象包含的字符构成了它所表示的字符串，还可以包含其他数据，例如字符的个数。因为 `string` 类型在 `<string>` 模块中定义，所以在使用 `string` 类型之前必须导入这个模块。`string` 类型名称也在 `std` 名字空间中定义，所以需要使用 `std::string` 来访问它，或者使用 `using` 声明将它引入当前作用域。

### 定义 string 对象

`std::string` 类型的对象包含 `char` 类型的字符序列，该字符序列可以为空。用下面的语句可以定义 `string` 类型的变量，它包含一个空字符串

```cpp
std::string empty; // 定义一个空字符串
```

这条语句定义了一个 `string` 对象，可以使用名称 `empty` 来引用它。在本例中，`empty` 是一个不包含字符的字符串，其长度为 $0$

在定义 `string` 对象时，可以使用字符串字面值来初始化它，例如

```cpp
std::string proverb {"Many a mickle makes a muckle."};
```

其中，`proverb` 是一个 `string` 对象，它包含初始化列表中字符串字面量的副本。`string` 对象封装的字符数组总是用空字符终止。这是为了与期望接收 C 风格字符串的众多现有函数保持兼容。

不过，所有的 `std::string` 函数都被特别定义，使得通过不必再担心终止空字符。例如，使用成员函数 `length()` 可以获得 `string` 对象的字符串长度。这个长度不包含字符串的终止字符

```cpp
std::cout << proverb.length() << std::endl; // 输出 29
```

这条语句调用 `proverb` 对象的 `length()` 成语函数，给 `cout` 输出返回的值。对象本身记录字符串的长度。即，要确定封装的字符串长度，`string` 对象不需要遍历整个字符串来寻找终止字符。如果追加一个或多个字符，其长度会自动增加合适的值；如果去除字符，其长度也会相应自动减少

::: warning

`std::string` 对象有两个成员函数 `c_str()` 和 `data()`，它们都返回一个指向 C 风格字符串的指针。只有在调用遗留的 C 样式的函数时，才应该调用这个两个成员函数中的一个。

+ `c_str()` 用于获得一个 C 风格的字符串。即，`const char *` 指针。因为是指向常量的指针，所以不能使用该指针来修改 `string` 对象中的字符，而是只能访问它们

+ `data()` 返回的是 `char *` 类型的指针（C++17 及更高版本）。可以通过这个指针修改字符串中的字符。但是，禁止添加和删除字符，否则会破坏 `string` 对象的内部状态，导致未定义行为。

注意：如果 `proverb` 是 `const` 类型的 `std::string` 对象，那么 `data()` 也会返回 `const char *` 类型的指针。在 C++17 之前，使用 `data()` 总是得到一个 `const char *` 指针，即使对于像 `c_str()` 这样的非 `const string` 也是如此

:::

除了使用字符串字面值初始化外，还可以使用其他方式初始化 `std::string` 对象，例如

```cpp
std::string sleeping(6, 'z'); // 包含 6 个 'z' 字符的字符串
```

`sleeping` 对象包含 $6$ 个字符 `'z'`，也就是说，`sleeping` 中包含字符串 `"zzzzzz"`。这就是使用同一个字符的任意个实例来初始化 `string` 对象的方式。

::: danger

要使用重复字符值来初始化 `std::string` 对象，**就必须使用函数式初始化**，而不能使用列表初始化语法。例如

```cpp
std::string sleeping {6, 'z'};  // 不是我们期望的结果
```

上述语句虽然能通过编译，但是不会是我们期望的结果。在本例中，字面值 `6` 会被解释为一个字符的编码，这意味着 `sleeping` 会被初始化为一个莫名奇妙的单词。它包含两个字符，但不是我们期望的 `"zzzzzz"`

:::

有时候，我们只希望使用字符串字面值中的某个部分来初始化 `std::string` 对象。例如

```cpp
std::string part{ "Least said soonest mended.", 5};  // 包含 "Least" 的字符串
```

在这个初始化器中的第二个值用于指定从第一个值中提取多少个字符来初始化 `part` 对象。

还可以使用 `string` 对象来初始化另一个 `string` 对象。假定 `proverb` 已定义，就可以使用下面的语句定义另一个对象

```cpp
std::string sentence {proverb}; // 使用 proverb 初始化 sentence
```

使用从 $0$ 开始的索引值可以引用 `string` 对象中的字符，这与数组一样。因此，可以使用一对索引值标识已有 `string` 对象的一部分，使用它初始化一个新的 `string` 对象

```cpp
std::string phrase {proverb, 0, 13}; // 包含 13 个字符，来自与 proverb 的开头
```

下图展示了这个过程

![1764601604924-d1aa34794ab320085a5eb2d7e0e530e2.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1764601604924-d1aa34794ab320085a5eb2d7e0e530e2.png)

初始化列表中的第一个元素是初始化字符串中源。第二个元素是 `proverb` 中开始初始化子字符串的字符索引，第三个元素是子字符串中字符的个数。所以，`phrase` 对象包含 `proverb` 对象中的前 $13$ 个字符，即字符串 `"Many a mickle"`。

为了演示创建了哪个子字符串，可以在输出流 `cout` 中插入 `phrase` 对象

```cpp
std::cout << phrase << std::endl; // 输出 Many a mickle
```

然后可以像 C 样式的字符串那样输出 `string` 对象。也可以从 `cin` 中提取 `string` 对象

```cpp
std::string name;
std::cout << "Enter your name: ";
std::cin >> name; // 从标准输入提取字符串
```

这个代码块会读取字符，直到遇见第一个空白字符为止，它会结束输入过程。读取的内容会存储在 `string` 对象 `name` 中。不能用这个过程输入包含空格的文本。当然，读取带空格的完整行文本，可以使用标准库 `<string>` 模块中的 `getline()` 函数

下表总结了前面提到定义和初始化 `string` 对象的 $6$ 种方式

|方式|描述|
|:----|:----|
|`std::string empty`|没有初始化列表(或者空列表`{}`)，初始化为空字符串|
|`std::string proverb {"Many a mickle makes a muckle."}`|使用字符串字面值初始化字符串|
|`std::string part {"Least said soonest mended.", 5}`|使用字符串字面值的一部分初始化字符串|
|`std::string sleeping(6, 'z')`|使用重复字符初始化字符串|
|`std::string phrase {proverb, 0, 13}`|使用已有字符串的一部分初始化字符串|

此外，还可以通过已有的 `std::string` 对象和一个整数初始化 `string` 对象。所创建的 `string` 对象包含从给定索引位置开始的子字符串。例如

```cpp
std::string string {"Consistency is the key to success"};
std::string sub_string {string, 15}; // 包含 "the key to success"
// 从索引为 15 位置开始，直到字符串末尾
```

### string 对象的操作

对 `std::string` 对象可以执行许多操作，最简单的操作是赋值。可以把字符串字面量或一个 `std::string` 对象赋予另一个 `std::string` 对象。例如

```cpp
std::string adjective {"hornswoggling"};
std::string word {"rubbish"};
word = adjective; // 现在 word 包含 "hornswoggling"
adjective = "twotiming"; // 现在 adjective 包含 "twotiming"
```

第三条语句把 `adjective` 的值 `"hornswoggling"` 赋给 `word`，替换掉 `"rubbish"`。最后一条语句给 `adjective` 赋予字符串字面量 `"twotiming"`，替换掉了初始值 `"hornswoggling"`。这样，执行这些语句后，`word` 就包含 `"hornswoggling"`, `adjective` 包含 `"twotiming"`。

#### 连接字符串

使用加号运算符 `+` 可以连接字符串。下面用刚才定义的对象来演示连接

```cpp
std::string description {adjective + " " + word + " " + whippersnapper};
```

执行这条语句后，`description` 对象就包含字符串 `"twotiming hornswoggling whippersnapper"`。显然，使用 `+` 运算符可以把字符串字面量与 `string` 对象连接在一起。这是因为对 `+` 运算符重新进行了定义，使 `string` 对象有了一个特殊的含义。当一个操作数是 `string` 对象时，另一个操作数是 C 风格字符串或者 `string` 对象时，执行 `+` 操作的含义就是：创建一个新的 `string` 对象，它把两个字符串连接成为一个字符串

::: warning

注意：**不能用 `+` 运算符来连接两个 C 风格字符串**。C 风格字符串本质上就是 `[const] char *` 类型的指针，C++ 中两个指针是不允许相加的。

`+` 运算符的操作数必须有一个是 `string` 类型的对象。例如，如下语句就不会进行编译

```cpp
std::string description {" whippersnapper" + " " + word}; // error
```

问题在于编译器试图把初始值计算为

```cpp
std::string description {(" whippersnapper" + " ") + word}; // error
```

换句话说，它计算第一个表达式是 `(" whippersnapper" + " ")`，而 `+` 运算符不能操作两个 C 风格字符串。

:::

针对上述问题，在 C++ 中至少有 $5$ 中解决方法

```cpp
// 1. 将前两个字符串字面值合并
std::string description {" whippersnapper " + word}
// 2. 省略字符串字面值之间的 +：编译器会自动合并两个相邻的字面值
std::string description {" whippersnapper" " " + word}
// 3. 使用圆括号，改变计算顺序
std::string description {" whippersnapper" + (" " + word)}
// 4. 将使用字符串字面值初始化一个 string 对象
std::string description {std::string{" whippersnapper"} + " " + word}
// 5. 使用自定义字面值: 后缀 "..."s 表示 string 类型的字面值
using namespace std::string_literals;  // 使用 s 后缀表示 `string` 类型必须添加该语句
std::string description {" whippersnapper"s + " " + word}
```

::: warning

如果想要使用 `std::string` 类型的字面值，就需要将 `using namespace std::string_literals` 指令添加进来

:::

来看下面一个示例程序，该示例程序从键盘上读取姓名

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string first;  // ""
    std::string second; // ""

    std::cout << "Enter your first name: ";
    std::cin >> first;

    std::cout << "Enter your second name: ";
    std::cin >> second;

    std::string sentence {"Your full name is "};
    sentence += first + " " + second + ".";

    std::cout << sentence << std::endl;
    std::cout << "The string countains " << sentence.length() << " characters." << std::endl;
}
```

::: tip

可以使用 `std::string` 对象的 `append()` 成员函数来替代 `+=` 运算符。使用该函时，可以像下面一样进行链式调用

```cpp
sentence.append(first).append(" ").append(second).append(".");
```

`append()` 成员函数比 `+=` 运算符更灵活，允许连接子字符串或重复字符

```cpp
std::string compliment{"~~~ What a beautiful name... ~~~"};
compliment.append(compliment, 3, 22);  // 添加 "What a beautiful name"
compliment.append(3, '!'); // 添加 "!!!"
```

:::

#### 连接字符

`std::string` 类型对象除了连接另一个 `string` 类型对象和字符串字面值外，还可以连接字符。例如

```cpp
sentenct += first + ' ' + second + '.';
```

当然，两个字符也是不能使用 `+` 运算符进行连接，因为 C++ 会把字符当作整数处理。

```cpp
sentence += second;
sentence += ',' + ' ';  // [!code highlight] 
sentence += first;
```

注意，上述代码片段可以通过编译，但是由于 C++ 把字符当作整数进行处理，字符 `','` 的编码值是 $44$，字符 `' '` 的编码值是 $32$，因此它们的和是 $76$，正好是字符 `'L'` 的编码。因此，上述代码片段完全在语法上完全正确，但是执行的最终结果却完全不符合预期

当然，如果像下面这样写就完全不会有问题

```cpp
sentence += second + ',' + ' ' + first;
```

原因在于，运算符 `+` 左相关的。因此，编译器会从左到右计算语句，如同下面的增加圆括号的语句一样

```cpp
sentence += ((second + ',') + ' ') + first;
```

::: warning

目前，我们都是将字符串字面值或者字符字面值与 `std::string` 类型进行连接。

在任何使用字符串字面值的地方都可以使用 C 风格字符串的其他形式替换，也就是说，可以使用 `[const] char *` 或者 `char[]` 类型变量与 `std::string` 类型的对象进行连接

:::

#### 连接数字

**C++ 不允许将 `std::string` 与字符串或者字符之外的其他类型进行连接**。例如，`double` 类型一般会导致编译错误

```cpp
const std::string result_string {"The result equals: "};
double result = std::numbers::pi;

std::cout << (result_string + result) << std::endl; // 编译错误
```

::: danger

最糟糕的就是 `std::string` 对象与整数进行连接，由于 C++ 将字符类型当作整数进行处理。因此，`std::string` 对象与整数连接是完全符合语法规则的。只是，不能得到我们想要的结果。例如

```cpp
std::string song_title {"Summer of'"};
song_title += 69;
std::cout << song_title << std::endl; // "Summer of 'E"
```

C++ 会将 $69$ 转换为对应编码的字符。而不是将其转化为字符串 `"69"`。我们必须使用标准库中的 `<string>` 模块提供的 `std::to_string()` 函数将基本类型转换为 `std::string` 对象

```cpp
std::string song_title {"Summer of'"};
song_title += std::to_string(69);
std::cout << song_title << std::endl; // "Summer of '69"
```

该函数也是存在缺陷的。不能使用该函数控制格式。因此，`std::to_string()` 总是会将浮点数以 $6$ 位小数格式输出

:::

当需控制格式时，请使用 `std::format()` 函数或者标准库中的 `<iomanip>` 模块

### 访问 string 中的字符

可以使用 `[index]` 形式，通过索引值来访问对应位置上的字符，甚至是修改这个字符，就行处理字符数组一样。`std::string` 对象中的第一个字符的索引是 $0$。例如，`sentence` 中的第三个字符可以通过 `sentence[2]` 表达式访问。下面的循环把 `sentenc` 中的所有字符改为大写

```cpp
for (size_t i{}; i < sentenc.length(); ++i>)
{
    sentence[i] = static_cast<char>(std::toupper(sentence[i]));
}
```

这里使用 `static_cast<>` 是为了避免编译器警告，因为 C 库函数 `toupper()` 的返回类型是 `int`，而不是期望的 `char` 类型

`std::string` 对象是一个范围，所以可以使用基于范围 `for` 循环完成上述操作

```cpp
for (auto &c : sentence)  // 注意，这里是左值引用
{
    c = static_cast<char>(std::toupper(c));
}
```

下面的示例程序演示了使用 `string` 类型版本的确定字符串中元音和辅音字母的个数

```cpp title="vowels2.cpp"
#include <iostream>
#include <string>

#include <cctype>

int main()
{
    std::string text;
    std::cout << "Enter a line of text: " << std::endl;
    std::getline(std::cin, text);  // 从 std::cin 中读取一行到 text 中
    
    std::cout << "You entered:\n" << text << std::endl;
    size_t vowels{};  // 元音字母个数
    size_t consonants{};  // 辅音字母个数

    for (const auto &ch: text)  // 我们不希望修改 text 中的字符 // [!code highlight]
    {
        // text[i] 是一个字母
        if (std::isalpha(ch))
        {
            switch (std::tolower(ch))
            {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                ++vowels;  // 元音字母个数 +1
                break;
            default:
                ++consonants;  // 辅音字母个数 +1
                break;
            }
        }
    }
    std::cout << "Your input contained " << vowels << " vowels and "
        << consonants << " consonants." << std::endl;
    return 0;
}
```

这个示例程序是在 [第五章 数组和循环#字符数组](./005-数组和循环.md#字符数组) 中的 `vowels.cpp` 示例程序的改进版本，主要的优点就是不需要考虑输入字符串的长度

::: tip

这里我们使用了在标准库 `<string>` 模块中定义的 `std::getline()` 函数，它从第一个参数(输入流)中读取字符，直到遇见换行符位置，并把输入存储在第二个实参指定的 `string` 对象 `text` 中。这次，我们不需要考虑输入中有多少个字符。`string` 对象自动容纳输入的内容，并记录其长度

如果需要修改结束符，还可以指定第三个实参，例如，使用 `'#'` 作为结束符

```cpp
std::getline(std::cin, text, '#');
```

:::

### 访问子串


