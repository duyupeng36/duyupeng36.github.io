---
title: 基本概念
createTime: 2025/11/13 22:09:25
permalink: /cppstudy/h45ai0rx/
tags:
  - C/C++
---

丹麦科学家 Bjarne Stroustrup 于 1985 年发明。到了 1998 年 ISO 颁布了 C++ 的第一个国际标准 ISO/IEC 14882:1998，既是我们常说的 C++98 标准。

几乎所有的应用程序都可以使用 C++ 开发；例如，设备驱动、操作系统、游戏等。C++ 最适合用于编写对性能要求高的应用程序； 例如，需要处理大量数据的应用程序、复杂图形处理的现代游戏、在嵌入式设备和移动设备上使用的应用程序；这些都是对执行性能有较高要求的程序。选用 C++ 开发的应用程序的执行效率通常要比其他语言编写的程序快数倍

虽然，C++ 已经被发明许多年了，但是依旧在快速发展，近年来发展速度明显加快。尤其是在 $2011$ 年，ISO 发布了 C++ 编程语言的全新版本， 这个版本也被称为 **C++11**，它使得 C++ 得到复苏。 C++11 深度地现代化了 C++ 语言和我们使用它的方式，**甚至可以将 C++ 当做一门全新的语言**

::: tip
使用 C++11 以及更新版本的 C++ 标准进行编程称为 **现代 C++** 编程。现代 C++ 编程并不只是简单使用现代 C++ 标准的新特性。最重要的是， **现代 C++ 编程方法是对良好编程风格达成的共识**。它使用一套指导原则和最佳实践，使 C++ 编程更简单、更安全并且生产效率更高
:::

C++11 标准的出现使得 C++ 社区再次活跃起来，C++ 社区一直努力地扩展和进一步改进 C++。每 3 年，就会发布一个新版本。 在 C++11 之后发布了 C++14、C++17、C++20 以及最新的 C++23

::: tip

+ C++14 和 C++17 相比较于 C++11 改动较少
+ C++20 的改动就比较大了，它改变了我们使用 C++ 编程的方式

我们将要学习的就是 C++20 版本
:::

如果每次编写程序都必须从头开始创建所有内容，就是一件非常枯燥的工作。很多程序都需要相同的功能，例如从键盘上读取数据、数学函数等，C++ 附带了大量预先编写好的代码，因此不需要我们自己编写它们

C++ 带有一个非常大的标准库，其中包含大量例程和定义，提供了许多程序需要的功能。C++ 标准库对于初学者而言是比较困难的。学习 C++ 就像学习开车一样，即使没有赛车需要的专业技能、知识和经验，也可以称为合格、安全的驾驶司机

## C++ 基本概念

下面展示一个完全可以工作的完整 C++ 程序

::: code-group

```cpp [first.cpp]
// first.cpp
// A complete C++ program
import <iostream>;

int main()
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

:::

如下图所示，解释了上述例程的各部分

![1760698880233-d1c183dca2b64702fa726c981fd794af.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760698880233-d1c183dca2b64702fa726c981fd794af.png)

如何执行这个程序呢？首先我们需要使用编译器将其编译为可执行程序，然后才能执行它。这里，我们使用 GCC 编译器来编译我们的程序。由 C++20 之后的标准尚未普及，因编译 C++20 的代码还比较复杂

```shell
# 第一步：首先编译模块。使用 GCC 时，我们必须手动编译 iostream、string、...等模块
g++ -std=c++23 -fmodules-ts -xc++-system-header iostream
# 第二步：编译目标代码
g++ -std=c++23 -fmodules-ts firstcpp.cpp -o firstcpp.exe
```

### 源文件

我们的示例代码是保存在一个名为 `first.cpp` 的文件中。文件扩展名 `.cpp` 表示这是一个 **C++ 源文件**。源文件包含函数体和程序中大部分可执行的代码。C++ 的源文件通常带有文件扩展名 `.cpp`。此外，还有其他的扩展名；例如 `.cc` `.cxx` 等

最开始我们学习 C++ 时，程序都会比较小，在一个 C++ 源文件中定义就足够了。但是，实际开发中，程序往往由成千上万个文件组成，这些文件并非都是源文件。在大型程序中，会使用其他类型的文件，目的是将程序各个组成部分的接口（函数原型、类定义、模块接口等）从源文件中的实现中分离出来

::: tip
源文件即是存储 C++ 实现代码的文件，通常以 `.cpp` 和 `.cc` 作为文件扩展名
:::

### 注释和空白

示例代码的前两行是 **注释**。添加注释用于解释程序代码，可以提高可读性，使他人可以更快的理解程序的工作方式。C++ 中，注释使用 `//` 开头，直到该行结束。编译器会忽略一行代码中 `//` 后面的内容

::: warning
注意：不要在每个文件开头的注释中指出文件名。示例代码只是为了演示
:::

C++ 还支持另外一种形式的注释，它可以让注释跨行存放

```cpp
/* This comment is
over two line
*/
```

编译器会忽略 `/*` 和 `*/` 之间的所有内容。这种注释通常用于文档说明

```cpp
/******************\
* This comment is *
* over two line.  *
\******************/
```

**空白** 是空格、制表符、换行符或者换页符等任意序列。编译器会忽略空白，除非由于语法原因需要使用空白把元素区分开来

### 标准库模块

示例代码的第三行 `import <iostream>;` 是一个导入声明，它将 C++ 标准库中的 `<iostream>` 导入到源文件 `firstcpp.cpp` 中。

::: code-group

```cpp{3} [first.cpp]
// first.cpp
// A complete C++ program
import <iostream>;

int main()
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

:::

这样，由该模块导出的所有类型和函数都可以在该文件中使用了。在编译之前，几乎在每个文件中都要导入一个或多个标准库模块。请注意：`<iostream>` 也可以作为头文件。实际上，在称为 C++20 的模块之前，它本就是一个头文件。C++20 之前标准库的所有头文件几乎都可以导入 C++20 中，作为模块使用。但是，源于 C 标准库的头文件则不行

### 函数

每个 C++ 程序都至少包含一个函数，通常会包含多个函数。**函数是一个命名的代码块**，执行定义好的操作，例如，读取输入数据、计算平均值或者输出结果。在程序中，使用函数的名称来执行或调用函数，**程序中的所有可执行代码都放在函数中**。C++ 程序中必须有一个名为 `main` 的函数，它是 C++ 程序的执行入口，程序执行总是会从这个函数开始

函数提供了几个重要的有点

+ 程序被分解为不同的函数，更容易开发和测试
+ 一个函数可以在程序的几个不同地方重用，从而降低程序的大小
+ 函数还可以在不同的程序中重用，节省开发时间
+ 大程序通常由不同的程序员共同开发。每个程序员可以负责不同的函数

我们的示例代码 `first.cpp` 中只包含 `main()` 函数。如下所示，

::: code-group

```cpp{5-14} [first.cpp]
// first.cpp
// A complete C++ program
import <iostream>;

int main()  // [!code focus]
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

:::

该函数的第一行是 `int main()`，称为函数头，标识了函数。其中 `int` 是一个类型名称，它定义了 `main()` 函数执行完毕时返回值的类型为整型

::: tip
整型既是存储整数的类型，它是没有小数部分的数字。例如 23 和 -2048 都是整数，但是 3.1415 和 $\frac{1}{4}$ 不是整数
:::

一般情况下，函数定义中名称后面的圆括号，包含了调用函数时需要传递给函数的信息和说明。函数的可执行代码总是放在花括号（`{}`）中，左花括号跟在函数头的后面

### 语句

**语句** 是 C++ 程序的基本单元，它总是以分号（`;`）结束。分号表示语句的结束。语句可以定义某个元素，例如计算或者要执行的操作。**程序执行的所有操作都是由语句指定的**。语句按顺序执行，除非某个语句改变了这个执行顺序。例如，`if` 语句。

我们的示例代码中的 `main()` 有 3 个语句。第一条语句定义了一个 **变量**，变量是一个命名的内存块，用于存储某种类型的数据。在示例代码中，变量的名称是 `answer`，可以存储整数值

```cpp
int answer {42};  // 定义变量 answer 存储整数 42
```

类型 `int` 放在名称的前面，指定了变量可以存储的数据类型——整数。注意 `int` 和 `answer` 之间有一个或多个必须得空白字符，用于分隔类型和变量名。如果 `int` 和 `answer` 之间没有空白字符，编译器会把名字看做 `intanswer`，这是编译器无法理解的。`answer` 的初始值放在变量名后的花括号中，所以它最初存储的值是 42。`answer` 和 `{42}` 之间的空格不是必须的。例如，如下几个变量的定义都是有效的

```cpp
int one { 1 };

int two{2};

int three{
    3
};
```

::: tip
虽然编译器会忽略多余的空格，但是在编程时应该以统一的风格使用空白字符，以提高代码可读性
:::

可以将多个语句放在一对花括号（`{}`）中，此时这些语句称为 **语句块**。函数体就是一个语句块。语句块也称为 **复合语句**，因此可以将复合语句看做是一条语句。在可以放置语句的任何地方，都可以放置一个包含在花括号中的语句块。因此，语句块也可以放在其他语句块内部，这个概念称为 **嵌套**。事实上，**语句块可以嵌套任意级别**

### 数据的输入和输出

在 C++ 中，输入和输出是使用 **流** 来执行的。如果要输出消息，可以把消息写入输出流中；如果要输入数据，则从输入流读取。因此，**流是数据源或数据接收器的一种抽象表示**。在程序执行时，每个流都关联着某台设备，关联着数据流就是输入流，关联着数据目的地的流就是输出流

对数据流或者数据接收器使用抽象表示的优点在于，无论流代表什么设备，编程都是相同的。例如，从磁盘文件中读取数据的方式与从键盘上读取是完全相同的

> [!tip]
>
> 在 C++ 中，标准的输出流和输入流分别称为 `cout` 和 `cin`，默认情况下，它们对应计算机的屏幕和键盘

在我们示例程序中的 `main()` 函数中将文本输出到屏幕的语句

```cpp
std::cout << "The answer to life, the universe, and everything is "
          << answer
          << std::endl;
```

名称 `cout` 和 `endl` 在 `<iostream>` 模块中定义。关于 `std::` 前缀稍后介绍。运算符 `<<` 是插入运算符，用于把数据传递到流中。后续我们还会介绍提取运算符 `>>`，它用于从流中读取数据。每个 `<<` 右边的所有内容都会传递到 `cout` 中。把 `endl` 写入 `std::cout`，会在流中写入一个换行符，并刷新输出缓冲区。

> [!tip]
>
> 刷新输出缓冲区可以确保输出立即显示

可以给每行语句添加注释。例如

```cpp
std::cout << "The answer to life, the universe, and everything is "  // This statement
          << answer                                                  // occupies
          << std::endl;                                              // three lines
```

双斜线不必对齐，但是我们通常对齐双斜线，使之看起来更整齐，代码更容易阅读。当然，不应该只是为了写注释而写注释。注释通常应该包含在代码中无法明显看出来的有用信息

### return 语句

`main()` 函数中的最后一个语句是 `return`。`return` 语句会结束函数，把控制权返回给调用函数的地方。在之前的示例代码中，它会结束函数，把控制权返回给操作系统。`return` 语句可能返回一个值，也可能不返回值。本例的 `return` 语句向操作系统返回 $0$，表示程序正常结束。程序可以返回非 $0$ 值，表示不同的异常结束条件。在 `main()` 函数中的 `return` 语句是可选的，可以忽略它。程序如果执行超过了 `main()` 函数中的最后一条语句，就等价于执行 `return 0`

::: warning
只有在 `main()` 函数中，忽略 `return` 才相当于返回 $0$。对于其他任何返回类型为 `int` 的函数，最好以一个显式的 `return` 语句结束，否则编译器不知道任意函数在默认情况下应该返回哪个值
:::

### 名字空间

大项目会同时涉及几个程序员，这样可能会导致名称问题。不同的程序员可能给不同的元素使用相同的名称，这可能会带来混乱，使程序出错。标准库定义了许多名称，很难全部记住。如果不小心使用了标准库名称也会出现问题。名字空间就是用于解决这个问题的

**名字空间类似于姓式**，置于该名字空间中声明的所有名字前面。标准库中的名称都在 `std` 名字空间定义，`cout` 和 `endl` 是标准库中的名称，所以其全名 `std::cout` 和 `std::endl`。其中的两个冒号（`::`）称为 **作用域解析运算符**。这里它用于分隔名字空间中的名字（例如 `cout` 和 `endl`）。名字空间的代码如下所示

```cpp
namespace my_space {
    // All names declared in here need to be prefixed
    // with `my_space` when they are referenced from outside.
    // For example, a `min()` function define in here
    // would be referred to outside this namespace as `my_space::min()`
}
```

花括号对中的所有内容都位于 `my_space` 名称空间中。在 [第 11 章 模块和名字空](./cpp-0x00b-模块和名字空.md) 中介绍

### 名字和关键字

在示例代码中包含变量 `answer` 的定义，并使用 `<iostream>` 标准库模块中定义的名字 `cout` 和 `endl`。程序中的许多元素都需要名称，定义名称的准确规则如下

+ 名字可以是包含大小写字母 `A ~ Z` 和 `a ~ z`、数字 `0 ~ 9` 和下划线 `_` 的任意序列
+ 名字必须以字母和下划线开头
+ 名字是区分大小写的

C++ 标准允许名称的任意长度，但有的编译器对此有某种长度限制，这种限制常常比较宽松，并不严格。大多数情况下，不需要使用长度超过 `12 ~ 15` 哥字符的名称

下面是一些有效的 C++ 名称

```cpp
toe_count   shoeSize    Box
doohickey   Doohickey   number1    x1    y2   pValue    out_of_range
```

**大小写字母是由区别的**，所以 `doohickey` 和 `Doohickey` 是不同的名称。编写由两个或多个单词组成的名称时，遵循几个约定

::: tip

+ **小驼峰约定**：把第二个以及之后的各个单词的首字母大写
+ **大驼峰约定**：把第一个以及之后的各个单词的首字母大写
+ **蛇形约定**：把每个单词使用下划线（`_`）分隔

:::

**关键字** 是 C++ 中有特殊含义的保留着，不能把它们用于其他目的。例如，`class`、`int`、`namespace`、`throw` 和 `catch` 都是保留字。此外，避免使用如下名字

+ 连续两个下划线开头的名字。例如，`__add`
+ 以一个下划线后跟一个大写字母开头的名字。例如，`_A`
+ 全局名字空间内所有以下划线开头的名字。例如，`_xxx`

虽然使用上述名字编译器并不会报错。但是，问题在于这些名称可能与编译器生成的名称冲突，或者与标准库实现在内部使用的名称冲突。

::: warning 警告
注意，这些保留名称都具备一个特征：**以下划线开头**。换句话说，在我们的程序中，**应该避免使用以下划线开头的名称**
:::

## 类和对象

**类是定义数据类型的代码**。类的名称就是数据类型的名称。类类型的数据项称为 **对象**。创建变量，以存储自定义数据类型的对象时，就要使用类类型的名称。如果定义自己的数据类型，就可以根据具体问题提出解决方案。例如，如果编写一个处理学生信息的程序，就可以定义 `Student` 类型。`Student` 类型可以包含学生的所有特征，例如年龄、性别或学校记录，这些都是程序需要的

## 模板

有时程序需要几个类似的类和函数，其他代码中只有处理的数据类型有区别。**编译器可以使用模板给特定的自定义类型自动生成类或函数的代码**。编译器使用类模板会生成一个或多个类系列，使用函数模板会生成函数。每个模板都有名称，在想要使用编译器创建模板的实例时，就会使用该名字。

在 [第 10 章 函数模板](./010-函数模板.md) 和 [第 17 章 类模板](./017-类模板.md) 中介绍模板。在 [第 21 章 受约束的模板和概念](./021-受约束的模板和概念.md) 结束如何通过添加概念表达式使模板的使用更安全、更容易

## 代码的表示样式和编程风格

代码的编排方式对于代码的可读性有非常重要的影响。这有两种基本的方式。首先，可以使用 **制表符** 或者 **空格** 缩进程序语句，显出这些语句的逻辑；再以一致的方式使用定义程序块的匹配花括号，使程序块之间的逻辑更清晰。其次，可以把一个语句放在两行或多行商，提高程序的可读性

通常，我们采用如下的样式。**可以根据自己的喜好和公司要求组织代码形式**

```cpp
namespace mine
{
    bool has_factor(int x, int y)
    {
        int factor { hcf(x, y) };
        if (factor > 1)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
}
```

或者

```cpp
namespace mine {
    bool has_factor(int x, int y) {
        int factor { hcf(x, y) };
        if (factor > 1) {
            return true;
        } else {
            return false;
        }
    }
}
```

## 创建可执行程序

从 C++ 源代码中创建可执行的模块通常需要三个步骤。

+ 第一步：预处理器处理所有预处理指令。一般来说，它的关键任务之一就是将所有 `#include` 头文件的完整内容复制到源文件中。但是，由于 C++20 中引入的模块将被淘汰
+ 第二步：编译器把每个源文件转换为对象文件，其他包含了与预处理代码对应的机器码
+ 第三步：链接器把程序的二进制文件合并到包含完整可执行程序的文件中

下图演示了 $3$ 个源文件经过编译后，生成 $3$ 个对应的对象文件。由于标识对象文件的文件扩展名在不同的机器环境中不同，因此没有显示。

![1760698954810-4a24cc47543c5840001f3dec666c3ce1.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760698954810-4a24cc47543c5840001f3dec666c3ce1.png)

组成程序的源文件可以在不同的编译器运行期间单独编译，但大多数编译器都允许在一次运行期间编译它们。无论采用哪种方式，编译器都把每个源文件看做一个独立的实体，为每个 `.cpp` 文件生成一个对象文件。然后在链接步骤中，把程序的对象文件和必要的库函数组合到一个可执行文件中

## 过程化编程和面向对象编程

历史上，过程化编程是编写几乎所有程序的方式。要创建文件的过程化编程解决方案，必须考虑程序实现的过程，才能解决问题。一旦需求明确地确定下来，就可以写出完成任务的大致提纲

+ 对程序要实现的整个过程进行清晰的说明
+ 将整个程序分为可工作的计算单元，这些计算单元应尽可能自包含的。它们常常对应于函数
+ 根据正处理的数据的的基本类型来编写函数

在解决相同问题时，面向对象编程方式除了开始时对问题进行清晰说明这一相同点之外，其他地方完全不同

+ 根据问题的详细说明确定该问题所涉及的对象类型。例如，程序涉及棒球运动员，就应该把 `BaseballPlayer` 标识为程序要处理的数据类型。如果程序是一个会计程序包，就应该定义 `Account` 类型和 `Transaction` 类型的对象。还要确定程序需要对每种类型执行的操作集合。这将生成一组与应用程序相关的数据类型，用于编写程序
+ 为问题需要的每种新数据类型生成一个详细的设计方案，包括可以对每种对象类型执行的操作
+ 根据已定义的新数据类型及其允许的操作，表达程序的逻辑

面向对象解决方案的程序代码完全不同于过程化解决方案，理解起来也比较容易，维护也方便得多。面向对象解决方案所需要的设计时间要比过程化解决方案长一些。但是，面向对象程序的编码和测试阶段比较短，问题也比较少，所以这两种方式的整个开发时间大致相同

下面简单介绍面向对象编程方式。假定要实现一个处理各种盒子的程序。这个程序的一个合理要求是把几个小盒子装到另一个大些盒子中。在过程化程序中，需要在一组变量中存储每个盒子的长度、宽度和高度。包含几个盒子的新盒子的尺寸必须根据每个被包含盒子的尺寸，按照为打包一组盒子而定义的规则进行计算

面向对象解决方案首先需要定义 `Box` 数据类型，这样就可以创建变量，引用 `Box` 类型的对象，并创建 `Box` 对象。然后定义一个操作，把两个 `Box` 对象加在一起，生成包含前两个 `Box` 对象的第三个 `Box` 对象。使用这种操作，就可以编写如下语句

```cpp
bigBox = box1 + box2 + box3;
```

这只是一个简单的说明，后续会相信介绍面向对象编程

## 计数系统

在 C++ 程序中，数字的表示有许多方式，所以必须理解表示数字的各种可能性。

### 二进制计数系统

要理解二进制，我们首先考虑常见的十进制数（例如 324 或 911）表示什么。在十进制数中

+ $324$ 是 $3 \times {10}^{2} + 2 \times {10}^{1} + 4 \times {10}^{0}$。也就是 $3 \times 100 + 2 \times 10 + 4 \times 1$
+ $911$ 是 $9 \times 10^2 + 1 \times 10^1 + 1 \times 10^0$

这称为 **十进制表示法**，因为它建立在 $10$ 的幂的基础上。也可以说，这里的数字以 $10$ 为 **基数** 来表示，因为每个数位都是 $10$ 的幂。

十进制表示数字对于人类来说非常方便。但是，对于计算机而言，就非常不方便了，**因为计算机主要以开关为基础，即开和关**，加起来只有 $2$，而不是 $10$。这就是计算机用基数 $2$ 而不是用基数 $10$ 表示数字的原因

用基数 $2$ 表示数字称为 **二进制计数系统**。用基数 $10$ 表示数字，每个数字可以是 $0 \sim 9$。一般情况下，以任意 $n$ 为基数表示的数，每个数位的数字范围是 $0 \sim n-1$。因此，二进制数字只能是 $0$ 或 $1$，二进制数 $(1101)_{2}$ 就可以分解为

$$
\begin{aligned}
(1101)_{2} &= 1 \sim 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 \\
&= 8 + 4 + 0 + 1 \\
&= (13)_{10}
\end{aligned}
$$

一般情况下，如果有 $n$ 位，就可以表示 $2^{n}$ 个整数，正值为 $0 \sim 2^{n}-1$

### 十六进制计数系统

在处理很大的二进制数时，将存在一个小问题。例如

```cpp
1111 0101 1011 1001 1110 0001
```

在实际应用中，二进制表示法显得比较繁琐，如果把这个二进制表示为十进制数，结果为 $16 103 905$，需要 $8$ 个十进制数位而已。显然，我们需要一种更高效的方式来表示这个数，但是十进制并不总是合适的。有时候需要指定二进制数中的某些位为 $1$。用十进制整数完成这个任务非常麻烦，而且容易出现计算错误。

更简单的解决方案是使用 **十六进制** 表示法，即数字以 $16$ 为基数表示。基数为 $16$ 的算术就方便许多，它与二进制也相得益彰。每个十六进制数字可以使 $0 \sim 15$ 的值（$10 \sim 15$ 的数字用 $A \sim F$ 或者 $a \sim f$ 表示），$0 \sim 15$ 的数值就分别对应于用 $4$ 个二进制数字表示，如下表

|十六进制|十进制|二进制|
|:----------|:------|:-----|
|`0`        |`0`    |`0000`|
|`1`        |`1`    |`0001`|
|`2`        |`2`    |`0010`|
|`3`        |`3`    |`0011`|
|`4`        |`4`    |`0100`|
|`5`        |`5`    |`0101`|
|`6`        |`6`    |`0110`|
|`7`        |`7`    |`0111`|
|`8`        |`8`    |`1000`|
|`9`        |`9`    |`1001`|
|`A` or `a` |`10`   |`1010`|
|`B` or `b` |`11`   |`1011`|
|`C` or `c` |`12`   |`1100`|
|`D` or `d` |`13`   |`1101`|
|`E` or `e` |`14`   |`1110`|
|`F` or `f` |`15`   |`1111`|

因为一个十六进制数对应于 $4$ 位二进制数，所以可以把较大的二进制数表示为一个十六进制数，方法是 **从右开始**，把每 $4$ 个二进制数组一组，再用对应的十六进制数表示每个组。例如，二进制数：

```cpp
1111 0101 1011 1001 1110 0001
```

如果依次提取每 $4$ 个二进制数，用对应的十六进制数表示每个组，将这个数字用十六进制表示，就得到：

```cpp
F 5 B 9 E 1
```

所得的 $6$ 个十六进制数分别对应于 $6$ 组 $4$ 个二进制数。为了证明这适用于所有情况，下面用十进制表示法把这个数字直接从十六进制转换为十进制。这个十六进制数的计算如下:

$$
\begin{aligned}
(F5B9E1)_{16} &= 15 \times 16^5 + 5 \times 16^4 + 11 \times 16^3 + 9 \times 16^2 + 14 \times 16^1 + 1 \times 16^0 \\
&= (16 103 905)_{10}
\end{aligned}
$$

显然，十六进制数与二进制数之间相互转换是非常方便的。只需要将十六进制数的每位数字转换 $4$ 位二进制数，然后按顺序放置即可。十六进制数的另一个非常方便的特定是，现代计算机把整数存储在偶数字节的字中，一般是 $2, 4, 8$ 或者 $16$ 字节，一个字节是 $8$ 位，正好是两个十六进制数，所以内存中的任意二进制整数总是精确对应于若干个十六进制数

::: tip
一个字节占 $8$ 位，正好可以存储两个十六进制数
:::

### 八进制计数系统

八进制数字是以 $8$ 为基数表示的数。八进制的数字是 $0 \sim 7$。目前，八进制数使用比较少。介绍八进制只是为了不要在 C++ 代码中出现混淆。在 C++ 代码中，支持八进制常量。八进制值有一个前导 $0$，所以 $76$ 是十进制数，而 $076$ 是八进制数，对应于十进制数是 $62$

::: warning
在 C++ 代码中，十进制数不允许出现前导 $0$，否则代表八进制数
:::

## 信息存储

现代计算机存储和处理的信息以 **二值信号** 进行存储的。二值信号就是只有两种状态的信号，例如 **开关的闭合与断开**、**穿孔卡片上有洞或无洞**、**导线上的高电压或低电压**、**磁带上有磁性和无磁性** 等。现代计算机中就是使用类似的二值信号表示信息。一般情况下，我们使用 $0$ 和 $1$ 表示

在计算机内部正是使用二值信号来处理信息的，二值信号也称为 **位(bits)**，二值信号的存储和计算的电子电路非常可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。请记住，**孤立的位是没有太多的作用**。然而，把多个位组合在一起，形成 **位模式**，再辅以某种 **解释**，我们就能够表示任何 **有限** 集合的元素。

::: tip
所谓的 **解释**，就是规定位模式表示的是什么类型的数据，也可以将解释称为 **类型**。
:::

下面我们将要学习的就是关于数字和字符的位模式解释

### 存储整数

每个整数（integer）都是是集合 $\cdots,-4,-3,-2,-1,0,1,2,3,4,\cdots$ 中的元素。整数应该如何存储在计算机内存中呢？在计算机科学中，整数被分为 **有符号数** 和 **无符号数** 两类，有符号整数包括负数和非负数，而无符号整数只包括非负数。

#### 有符号整数

由于符号数包含负数，有符号整数在计算机内如何存储是围绕计算机该如何表示符号展开。现代计算机中有 $3$ 种方法编码有符号数，分别是 **符号+绝对值（原码）**、**反码**、**补码**

##### 符号+绝对值

**符号+绝对值** 编码形式将 **最高有效位** 用于表示符号：其中 0 表示负数，1 表示正数。因此，它将无符号整数的有效范围拆分为两个相等的子范围。换句话说，**最高有效位是用来确定剩余的位表示的值应该取负权还是正权**。对于 $n$ 位位模式 $\vec{w} = [w_{n-1}, w_{n-2}, \cdots, w_1, w_0]$ 采用使用 **符号+绝对值** 形式解释时表示的值如下

$$
B2S_{n}(\vec{w})=(-1)^{w_{n-1}}\cdot \left(\sum_{i=0}^{n-2}x_{i}2^{i}\right)
$$

假设位模式长度为 $8$，下表展示了几个整数的位模式

| 整数 |位模式|
|:----|:-----|
|`4`|`0000 0100`|
|`-4`|`1000 0100`|
|`1`|`0000 0001`|
|`-1`|`1000 0001`|
|`0`|`0000 0000`|
|`-0`|`1000 0000`|

::: warning
观察到，在符号+绝对值 编码中存在 **"负零"** 的情形，即同一个零值有两种表示方式，**既浪费了一个编码**。

由于要考虑数的符号，这会导致运算电路变得复杂。在进行算术运算时，CPU 必须先判断符号位，然后才能进行计算
:::

例如，想要计算 `1000 0100(-4) - 0000 1000(8)`，首先要判断两个操作数的符号是否相同；如果不相同，还要比较绝对值的大小，从而确定运算结果的符号。

##### 反码

为了解决 符号+绝对值 编码在运算上的不便，从而提出了 **反码** 编码。与 **符号+绝对值** 编码不同的是，最高有效位不仅仅表示符号，还带有了权 $-(2^{w-1}-1)$ 。也就是说，对于 $n$ 位位模式 $\vec{w} = [w_{n-1}, w_{n-2}, \cdots, w_1, w_0]$ 采用使用 **反码** 形式解释时表示的值如下

$$
B2O_{n}(\vec{w}) = -w_{w-1}(2^{n-1}-1) + \sum_{i=0}^{w-2}x_{i}2^{i}
$$

反码的出现简化了减法运算，因为 `a - b` 可以转换为 `a + (-b 的反码)` 形式计算。但是，仍然存在 **"负零"** 的情形，此时 **"负零"** 编码为 `1111 1111`。如果计算发生了 **进位**，这个进位不能简单丢弃。反码虽然简化了减法运算，但是没有解决 **负零** 的问题。同时，运算规则也不够统一

##### 补码

在现代计算机中，有符号数采用 **补码** 进行编码的。补码编码与反码类似，唯一不同的就是最高位的权。在这个定义中，$n$ 位位模式 $\vec{w} = [ w_{n-1}, w_{n-2}, \cdots, w_{1}, w_{0}]$ 的最高有效位被解释为负权 $-2^{n-1}$

$$
B2T_{n}(\vec{w}) = -w_{n-1}\cdot 2^{n-1} + \sum_{i=0}^{n-2} w_{i} \cdot 2^{i}
$$

::: tip
最高有效位 $w_{n-1}$ 称为符号位，其权重为 $-2^{w-1}$
:::

符号位被设置为 $1$ 时，表示值为负，而当符号位被设置为 $0$ 时，值为非负。例如

$$
\begin{aligned}
&B2T_4([0001]) = - 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1  \\
&B2T_4([0101]) = - 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 4 + 0 + 1 = 5\\
&B2T_4([1011]) = -1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 0 + 2 + 1 = -5 \\
&B2T_4([1111]) =-1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 4 + 2 + 1 = -1
\end{aligned}
$$

让我们来考虑一下 $n$  位补码所能表示的值的范围

::: tip
补码编码能表示的 **最小值** 的位向量为 $[1,0,\cdots, 0, 0]$，也就是设置这个位为负权，但是清除其他所有的位；其整数值为 $TMin_{n} = -2^{n-1}$

补码编码能表示的 **最大值** 的位向量为 $[0,1,\cdots,1,1]$，也就是清除具有负权的位，而设置其他所有的位；其整数值为 $TMax_{n} = 2^{n-1}-1$

显然，$n$  位补码表示整数的范围为 $[-2^{n-1}, -2^{n-1}-1]$
:::

例如，长度为 $4$ 位的补码能够表示的整数范围是 $[-2^{4-1}, -2^{4-1}-1]==[-2^3, 2^3-1] == [-8, 7]$

---



如何获将十进制负整数转换为二进制补码表示？ 为了回答这一个问题，需要了解两个概念：**补数** 与 **减补数**

自然数 $a$ 在给 $N$ 进制下的 **补数** 定义为：对于给定的 **进制 $N$**，与自然数 $a$ 相加后使得得 **位数** 增加 $1$ 的最小的数

+ $N$ 进制数 $a$ 关于 **基数($N$)的补数** ($N$ 的补数): $N^{n}-a$。其中 $n$ 是数 $a$ 的位数
+ $N$ 进制数 $a$ 关于 **减基数($N-1$)的补数** ($N - 1$ 的补数)，简称 **减补数**、侪补数: $N^{n}-a-1$。其中 $n$ 是数 $a$ 的位数

例如，十进制自然数 $61$ 关于基数 $10$ 的补数就是 $10^2 - 61 = 39$。二进制自然是 $10010_2 ( = 18_{10})$ 关于基数 $2$ 的补数是 $2^b - 18 = 1110_2=(14_{10})$

::: tip
从定义可以得出， $n$ 位数 $a$ 关于基数 $N$ 补数加上 $a$，可以得到位数多一位的最小自然数 $N^n$。$n$ 位数 $a$ 的减基数的补数加上 $a$ 可以得到位数不变的最数 $N^n - 1$
:::

注意观察，十进制自然数 $61$ 和其减基补数 $38$。显然，$6 + 3 = 9; 1 + 8 = 9$。也就是说，对于 $n$ 位 $N$ 进制数自然数 $a_{n} = a_{n-1}a_{n-2}\cdots a_{1}a_{0}$ 和  $b_{n} = b_{n-1}b_{n-2}\cdots b_{1}b_{0}$ 只要每一位满足如下关系

$$
b_{i} + a_{i} = N - 1, i = 0, 1, \cdots, n-1
$$

时，就称 $a_{n}$ 和 $b_{n}$ 互为减基补数。$a_{n}$ 的补数就是 $b_{n} + 1$; $b_{n}$ 的补数就是 $a_{n} + 1$

::: tip
对于二进制而言, $b_{i} + a_{i} = 2 - 1 = 1$；换句话说，二进制自然数 $a$ 的减基补数  $b$ 就是将  $a$ 每一位进行反转；补数就是  $b + 1$
:::

我们来看一个例子。对于十进制的负数 $-10$，使用 $8$ 位补码位模式表示如下。

+ 首先，计算 $10$ 的位模式 $0000 1010$
+ 然后，求 $0000 1010$ 的减基补数 $1111 0101$
+ 最后，减基补数 $1111 0101 + 1 = 111 0110$

::: tip
请注意：`-a` 的绝对值 `|-a|` 的二进制表示下的减减基补数就是 `-a` 的反码编码

所谓 **反码** 就是 `|-a|` 的二进制表示进行按位取反后得到的编码
:::

#### 无符号整数

假设一个整数数据类型有 $w$ 位。我们可以将位模式 $\vec{w} = \left[w_{n-1}, w_{n-2} \cdots, w_2,w_1,w_0\right]$ 看作一个二进制表示的数，就获得了 $\vec{w}$ 的无符号表示

::: tip
这个编码中，每个位 $w_i$，都取值为 0 或 1。当 $w_i$ 取值为 1 时，意味着数值 $2^i$ 应为数字值的一部分
:::

因此，无符号数编码的定义为：对于位模式 $\vec{w} = \left[w_{n-1}, w_{n-2} \cdots, w_2,w_1,w_0\right]$

$$
B2U_n(\vec{w}) = \sum_{i = 0}^{n-1}w_i \cdot 2^i
$$

函数 $B2U_n$ 将一个长度为 $n$ 位的 $0, 1$ 串映射到非负整数。例如

$$
\begin{aligned}
&B2U_4([0001]) = 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1  \\
&B2U_4([0101]) = 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 4 + 0 + 1 = 5\\
&B2U_4([1011]) = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 0 + 2 + 1 = 11 \\
&B2U_4([1111]) =1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 4 + 2 + 1 = 15
\end{aligned}
$$

接下来考虑 一 下 $n$ 位无符号编码所能表示的值的范围

::: tip
**最小值** 使用位向量 $[0,0,\cdots, 0,0]$ 表示，也就是整数 $0$

**最大值** 使用位向量 $[1,1,\cdots,1,1]$ 表示，也就是整数 $UMax_{n}=\sum_{i=0}^{n-1} 2^i = 2^n - 1$
:::

### 字节序

整数在内存中的系列连续字节中存储为二进制值，通常存储为$2, 4, 8$ 或者 $16$ 字节。整数的二进制表示按照字节分组后，这些分组采用什么顺序存放到内存中是非常重要的

把十进制数 $262657$ 的二进制值为：

```cpp
00000000 00000100 00000010 00000001
最高字节                    最低字节
```

::: tip
假设一个 $w$ 为的整数，其位模式为 $[x_{w-1},x_{w-2}, \cdots., x_{1}, x_{0}]$，其中 $x_{w-1}$ 是 **最高有效位**；$x_0$ 是 **最低有效位**

假设 $w=8 \cdots 8k$ 其中 $k=1,2,\cdots$，这些为就能分组成为字节，其中 **最高有效字节** 包含 $[x_{w-1},x_{w-2},\cdots,x_{w-8}]$；**最低有效字节** 包含 $[x_{7},x_{6}, \cdots,x_{0}]$
:::

如果将其存储到 $4$ 字节内存中。在 Intel 处理器的计算机上，该数字的存储形式如下

```cpp
---------------------------------------------------------------------
字节地址:   00              01              02              03
数据位:     00000001        00000010        00000100        00000000
---------------------------------------------------------------------
```

可以看出，值中的 **最高有效字节都存储在地址最高位字节中**；最低有效字节存储在地址最低的字节中；这种安排形式称为 **Little-Endian(小端)**。现代计算机大多数都是采用的这种方式。当然，也有例外情形。对于使用 Motrola 处理器的机器，该数字在内存中存储更加符合逻辑

```cpp
---------------------------------------------------------------------
字节地址:   00              01              02              03
数据位:     00000000        00000100        00000010        00000001
---------------------------------------------------------------------
```

最高有效字节存储在地址最低的字节中；最低有效值字节存储在地址最高的字节中；这种安排形式称为 **Big-Endian(大端)**。

知晓系统采用 Little-Endian 还是 Big-Endian 是非常重要的。尤其是当我们在处理来自另一台计算机的二进制数据。二进制数据会写入文件或者通过网络传送为一系列的字节，这是必须解释它们。如果数据源所在的机器使用的字节序与运行代码的机器不同，就必须反转每个二进制数据的字节序，否则会出错。下图展示了 `0x01234567` 数字的小端和大端字节序时如何存储的

![1760699007338-5a9065b0df4b70a28dbaf0361a107f51.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760699007338-5a9065b0df4b70a28dbaf0361a107f51.png)

::: info
C++20 标准库在 `<bit>` 模块中引入 `std::endian::native`，可以用来判断程序是针对 Big-Endian 平台还是 Little-Endian 平台
:::

### 存储浮点数

应用程序有时需要处理小数，甚至会很大或者很小的整数数字。显然，我们需要一种能够在计算机中表示小数的并且能够高效的对小数进行计算的方法。现代计算机采用 **浮点数编码** 来处理小数，这是因为小数点在这种编码方式中是浮动的而得名

浮点数编码的灵感来自于 **科学计数法**，它可用来表示由于 **太大** 或 **太小** 而不能方便地用十进制表示的数，因为这样做需要写出一串异常长的数字。对于 $N$ 进制数 $a = \pm a_{n-1}a_{n-2}\cdots a_{1}a_{0}.a_{-1}a_{-2}\cdots a_{-m}$ 的科学计数法表示如下

$$
a = \pm a_{n-1}.a_{n-2} \cdots a_{0}a_{-1}a_{-2}\cdots a_{-m} \times N ^ {n-1}
$$

其中 $\pm$ 是 **符号**；$a_{n-1}.a_{n-2} \cdots a_{0}a_{-1}a_{-2}\cdots a_{-m}$ 是 **尾数**；$n-1$ 是 **指数**。

::: tip
随着指数的不同，尾数中的浮点数也会发生相应的变化。例如，3147 的科学计数法表示可以是

+ $3.147 \times 10 ^ {3}$
+ $0.03147 \times 10 ^ {5}$
+ $31.47 \times 10 ^ {2}$
+ $3147000 \times 10 ^ {-3}$

在这些表示中，小数点之前保留一位非零数字的科学计数法表示称为 **规格化数**。对于二进制而言，规格化数一定以 $1$ 开头
:::

显然，在科学计数法表示中，**符号、指数 和 尾数 是最重要的**。大多数现代计算机都采用 IEEE 754 binary 浮点数编码标准，该标准规定了如下图所示的三种浮点数格式

![1759497113227-1f1cd432d9b2e601afe893317b53c446.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760869654967-1f1cd432d9b2e601afe893317b53c446.png)

很明显，**符号位** 占 $1$ 位，$0$ 表示负数，$0$ 表示正数。对于规格化 **尾数** 采用无符号数表示，由于二进制规格化数中，小数点左边只能是 $1$。指数可以是正数也可以是负数，IEEE 754 binary 标准中采用 **移码** 编码

::: tip
[移码](https://en.wikipedia.org/wiki/Offset_binary) 也称 **偏置二进制** 编码，是一种 [有符号数字表示](https://en.wikipedia.org/wiki/Signed_number_representation "Signed number representation") 方法。每个有符号数字 $n$ d的移码编码对应于无符号数 $n + bias$ 的位模式表示，其中 $bias$ 是 **偏置值** 或 **偏移量**

偏置二进制编码没有标准：在大多数情况下，$k$ 位偏置二进制编码的 偏置值为 $bias=2^{k-1}$

在 IEEE 754 标准中，指数部分采用的偏置值是 $2^{k-1}-1$。
:::

了解了 IEEE 754 binary 浮点格式后，现在讨论几个特殊值的 IEEE 754 binary 的编码

+ IEEE 754 binary 格式的 $\pm 0$: 指数位全为 0，尾数为全为 0

    ![1760870896639-c070b008836cf807f10d62741b2983db.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760870896639-c070b008836cf807f10d62741b2983db.png)

+ IEEE 754 binary 格式表示的 $\pm \infty$: 指数为全为 1，尾数位全为 0

    ![1760870961002-f9f87c7e3f73ec3c996f7ed9bbc91591.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760870961002-f9f87c7e3f73ec3c996f7ed9bbc91591.png)

+ IEEE 754 binary 格式的 NaN：指数全为 1，尾数不全为 0

    ![1760870996864-db6a9793663f817ccbc03b0ef4f0d7d4.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760870996864-db6a9793663f817ccbc03b0ef4f0d7d4.png)

对于某些非常接近零的数，规约化数可能无法表示。因此，非规约化数的编码也需要支持。非规约数编码为 **指数位全为 0，尾数位非零**，那么这个浮点数将被称为**非规约形式的浮点数**

![1760871305077-afda2594290d6f5b0215d96d8a3a3cb0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760871305077-afda2594290d6f5b0215d96d8a3a3cb0.png)

IEEE 754标准规定：**非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小 1**。最小的规约形式的单精度浮点数的指数部分编码值为 1，指数的实际值为 -126；而非规约的单精度浮点数的指数域编码值为 0，对应的指数实际值也是 -126 而不是 -127。例如，以 binary32 表示的位模式 $[b_{31}, \Vert 0_{30}, \cdots, 0_{23}\Vert,  0_{22},\cdots,b_2,b_1,b_0]$ 表示的非规约浮点数值为

$$
(-1)^{b_{31}} \times 2^{-126} \times (0.b_{22}b_{21}\cdots b_{2}b_{1}b_{0})_2
$$

## 表示字符

计算机中的数据没有内在含义的，必须辅以某种解释才能决定数据的含义。例如，机器指令在内存中只是一些位模式、数字在内存中也是位模式。计算机要处理字符，那么也需要将字符转变为位模式。在内存中的值 $42$ 可以是钼原子的原子序数，也可以是星号字符。

将字符转换为位模式的就可以让字符对应一个独特的整数值，称为代码或代码点。例如，使用长度为 $4$ 的位模式可以表示 $2^4$ 个字符

### ASCII 码

20 世纪 60 年代，美国国家标准协会(ANSI)开发了一个被称为 **美国信息交换标准码**(ASCII)的代码。该代码使用长度为 7 的位模式表示一个符号。也就是说，ASCII 编码定义 $2^7=128$ 种不同的符号。其中 $0 \sim 31$ 表示各种 **非打印** 的控制字符，例如 回车符、换行符等。$65 \sim 90$ 对应了大写字符 $A \sim Z$；$97 \sim 122$ 对应了小写字符 $a \sim z$

::: tip
ASCII 编码中，大小写字母的编码只在第 6 位上有差异；小写字母的 ASCII 编码的第 6 位是 $1$, 大写字母的 ASCII 编码的第 6 位是 $0$
:::

对于 ASCII 编码，需要我们记忆的几个字符编码

|         字符         |    位模式     | 十进制  |  十六进制   |
| :----------------    | :--------    | :-----  | :----- |
| `NULL` 字符 (`'\0'`) | `000 0000` | `0`  | `0x00` |
| `SPACE` 字符 (`' '`) | `010 0000` | `32` | `0x20` |
|  `HT` 字符 (`'\t'`)  | `000 1001` | `9`  | `0x09` |
|  `CR` 字符 (`'\r'`)  | `000 1101` | `13` | `0x0d` |
|  `LF` 字符 (`'\n'`)  | `000 1010` | `10` | `0x0a` |
|  `VT` 字符 (`'\v'`)  | `000 1011` | `11` | `0x0b` |
|  `FF` 字符 (`'\f'`)  | `000 1100` | `12` | `0x0c` |
|      字符 `'0'`      | `011 0000` | `48` | `0x30` |
|      字符 `'1'`      | `011 0001` | `49` | `0x31` |
|      字符 `'A'`      | `100 0001` | `65` | `0x41` |
|      字符 `'a'`      | `110 0001` | `97` | `0x61`  |

7 位的 ASCII 编码只适合使用拉丁字符的国家；例如，英国或美国。对于法国和德国，字符中需要重音和元音变音，这些没有包含在 ASCII 字符集中。因此，对 ASCII 编码进行了扩展，采用 $8$ 位位模式进行编码，这种编码称为 **Latin-1**

然而，对于使用象形文字的国家；例如，中国；采用 8 位编码显然是不够的。并且不同地区使用不同的编码，就会导致各个地区在使用计算机交流上出现困难。因此，20 世纪 90 年代通用字符集（Universal Character Set，**UCS**）被发明。目前，UCS 的标准是 ISO 10646 定义，该标准采用 32 位位模来编码字符，提供了数亿个不同的字符编码

### UCS 和 Unicode

UCS 定义了字符和整数之间的映射关系。UCS 代码和编码是不同的

+ **代码点是一个整数**
+ **编码是将代码点表示为一系列的字节或字的方式**

对于值小于 $256$ 的代码点只需要 $1$ 字节即可表示。如果以固定字节存储，就需要使用 $4$ 字节存储只需要 $1$ 字节的代码值。当需要进行网络传输或者写入文件时，这种无效的字节会导致低效。

因此，我们需要将一个 UCS 代码值进行编码，从而允许以变长的方式存储一个 UCS 代码值。目前，**使用最广泛的是 Unicode 编码**。

请注意：Unicode 是一个标准，定义了一组字符及其代码点(与 UCS 相同)。此外，Unicode 还为这些代码点定义了一组编码方式，称为 **Unicode 转换格式**（Unicode Transformation Format，**UTF**）。最常用的编码方式是 **UTF-8**、**UTF-16** 和 **UTF-32**，它们都可以表示 Unicode 字符集合中的所有代码点；区别在于如何表示给定字符的代码点

+ UTF-8 把 Unicode 代码值编码为 $1 \sim 4$ 个字节的位模式
+ UTF-16 把 Unicode 代码值编码为 $2$ 或者 $4$ 字节位模式
+ UTF-32 把 Unicode 代码值编码为 $4$ 字节的位模式

下图展示了 UTF-8 编码 Unicode 代码值的过程

![1760886165334-3715b12195f349bfad34f35bcea652c0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760886165334-3715b12195f349bfad34f35bcea652c0.png)

## 源字符

编写 C++ 程序需要使用 **基本源字符集**，这些是在 C++ 源文件中可以显式使用的字符集。用于定义名字的字符集是上述字符集合的子集。基本源字符集并没有限制代码中使用的字符数据。基本源字符集必须包括下面这些字符

+ 大小写字母：$A \sim Z$ 和 $a \sim z$
+ 数字字符： $0 \sim 9$
+ 空白字符：空格、制表符等
+ 其他字符：`_ {} [] # () <> % : ; . ? * + - / ^ & | ~ ! = , \ " '`

::: warning
请注意：程序可以用各种方式创建没有包含在上述字符集中的字符串。
:::

大多数情况下，基本源字符集足够使用了，但是偶尔需要使用不包含在基本源字符集中的字符。至少理论上，可以在 C++ 名称中包含 Unicode 字符

字符和字符串数据可以包含 Unicode 字符。如果想要以任何编译器都可以接受的形式在字符或字符串字面值中包含 Unicode 字符，应该使用 Unicode 代码值的十六进制表示。换言之，应该以 `\udddd` 或 `\Udddddddd` 的形式输入字符，其中 `d` 是一个十六进制数

### 转义序列

在程序中使用字符常量时，某些字符可能无法从键盘中输入。例如，ASCII 编码在 $0 \sim 31$ 的非打印字符就无法直接输入为字符常量。通过 **转义字符** 可以把这些非打印字符当做字符常量。转义字符是指定字符的一种间接方式，总是以一个反斜杠 `/` 开头。下表列出来常用的 C++ 编译器允许的转义字符

| 字符转义序列 | 描述   | 表示                  |
| ------ | ---- | ------------------- |
|        |      |                     |
| `\'`   | 单引号  | ASCII 编码中为字节 `0x27` |
| `\"`   | 双引号  | ASCII 编码中为字节 `0x22` |
| `\?`   | 问号   | ASCII 编码中为字节 `0x3f` |
| `\\`   | 反斜杠  | ASCII 编码中为字节 `0x5c` |
| `\a`   | 响铃   | ASCII 编码中为字节 `0x07` |
| `\b`   | 退格   | ASCII 编码中为字节 `0x08` |
| `\f`   | 换页   | ASCII 编码中为字节 `0x0c` |
| `\n`   | 换行   | ASCII 编码中为字节 `0x0a` |
| `\r`   | 回车   | ASCII 编码中为字节 `0x0d` |
| `\t`   | 水平制表 | ASCII 编码中为字节 `0x09` |
| `\v`   | 垂直制表 | ASCII 编码中为字节 `0x0b` |

上表中的前 3 个转义字符是打印字符，因为它们在 C++ 源代码中有特殊含义，转义字符就将其当做普通字符处理。否则，这些字符在源代码中直接表示会出现问题。

例如，表示反斜杠字符常量是很困难的，因为它被用作转义字符的开头。表示单引号字符常量也很困难，因为它作为字符常量的界定符，例如，字符常量 `'A'` 。表示双引号字符常量也是如此，因为它作为字符串字面值的界定符，例如，字符串字面值 `"hello, world!"`

如下示例程序，演示了转义字符的简单使用

```cpp
// escape.cpp
// Using escape sequences

import <iostream>;

int main()
{
    std::cout << "\"Least \'said\' \\ \n\t\t soonest \'mended\'.\"" << std::endl;
    return 0;
}
```

上述代码编译运行后的结果如下

```shell
"Least 'said' \
                 soonest 'mended'."
```

## 练习

### 向屏幕输出 `"hello, world!"`

```cpp
import <iostream>;

int main()
{
    std::cout <<"hello, world!\n";
    return 0;
}
```

### 向屏幕输出自己的名字和年龄

```cpp
import <iostream>;

int main()
{
    std::cout << "My name is " << "zhangsan. " << "I'm 28 years old.\n";
    return 0;
}
```

### 更正下列程序

```cpp
// 第一处错误。import 前不需要 #
#import <iostream>  // 第二处错误：import 是语句，需要使用 ; 结尾

// 第三处错误：必须小写 int
Int main  // 第四处错误：main 后面需要圆括号 ()
{
    std::cout << "Hola Mundo!" << std::endl  // 第五处错误：语句要以分号结尾
}
```
