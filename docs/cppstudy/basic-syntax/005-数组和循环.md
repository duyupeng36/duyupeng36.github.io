---
title: 数组和循环
createTime: 2025/11/16 22:17:52
permalink: /cppstudy/zot30i85/
tags:
  - C/C++
---

**数组** 允许用单个名称(数组名)处理类型相同的几个数据项。这是一个非常常见的需求，例如，处理一组温度值或者一组人的年龄。**循环** 是编程中的另一个基本要素。它允许对一个或多个语句重复执行应用程序需要的次数

## 数组

前面创建的所有变量都可以存储指定类型的一个数据项，例如整数、浮点值、字符、布尔值等。**数组可以存储相同类型的多个数据项**。可以创建整数数组或者字符数组，**实际上，可以创建任何数据类型的数组，只要有可用的内存，数组就可以存储任何类型的数据**

数组表示一系列内存空间的变量，每个内存空间都可以存储相同类型的一个数据项。例如，假定编写了一个程序，用来计算一年温度的平均值。现在要扩展这个程序，计算比该平均值高的温度有多少个，比该平均值低的温度有多少个。此时，需要保存初始的示例数据，但在一个变量中存储每个数据项，程序就会很烦恼，而且不切实可行。使用数组就可以很轻松地完成这个任务。例如

```cpp
double temperatures[366];  // 定义一个长度为 366 的 double  类型的数组 temperatures
```

这个语句定义了一个 `double` 类型的数组，其名称是 `temperatures`，有 $366$ 个值。把数据值称为 **元素**，把在方括号中指定的元素个数称为 **数组的大小**。数组元素没有在这个语句中初始化，所以它们包含垃圾值。

**数组的大小必须用常量整数表达式来指定**。编译器在编译时能够计算的任何整数表达式都可以用于指定数组大小，不过最常用的整数字面值，或者使用字面值进行初始化的 `constexpr` 整型变量

使用一个整数可以引用数组元素，把该整数称为 **数组的索引**。**数组元素的索引是指该元素与数组第一个元素的偏移值**。第一个元素的偏移值是 $0$，因此其索引是 $0$，索引值为 $3$ 表示数组中的第 $4$ 个元素(与第一个元素偏移 $3$ 个元素)。要引用元素，可以在数组名后面的方括号中放置其索引。要把 `temperatures` 数组的第 $4$ 个元素设置为 $99.0$，可以使用如下语句

```cpp
temperatures[3] = 99.0;  // 设置第四个元素为 99.0
```

为了更好的说明数组，来看下面一个数组的定义

```cpp
unsigned int height[6];  // 定义一个长度为 6 的数组 height
```

在执行这个定义语句时，编译器为这 $6$ 个 `unsigned int` 类型的值分配 $6$ 个连续的存储位置。`height` 数组中的每个元素都包含不同的值。因为 `height` 数组的定义没有为数组指定初始值，所以其元素包含的垃圾值(类似于创建一个 `unsigned int` 类型的变量，但不为其指定的初始值)。下面的语句定义了带初始值的数组

```cpp
unsigned int height[6] {26, 37, 47, 55, 62, 75}; // 定义并初始化长度为 6 的数组
```

初始化列表包含 $6$ 个用逗号隔开的值。这些值可能是某个家庭中所有成员的身高，其单位是英寸。每个数组元素都按顺序被赋予列表中的一个初始值，所以元素具有如下图所示的值

![1763307080799-38fd35eb3037375beb8f687ad1515f9e.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763307080799-38fd35eb3037375beb8f687ad1515f9e.png)

上图中每个框都表示保存数组元素的一个内存位置。该数组中有 $6$ 个元素，其索引是 $0$(表示第一个元素)到 $5$(表示最后一个元素)。每个元素都可以通过上面的表达式来引用

::: warning

数组的类型决定了存储每个数组元素所需要的内存量。数组的所有元素都存储在一个连续的内存块中。因此，如果 `unsigned int` 类型的值在计算机中需要 $4$ 字节，则 `height` 数组就需要占用 $24$ 字节

:::

**初始化列表中值的个数不能超过数组的元素个数**，否则该语句不会编译。初始化列表中值的个数可以少于数组的元素个数，此时没有提供初始值的元素就初始化为 $0$(对于 `bool` 元素数组则为 `false`)

```cpp
unsigned int height[6] {26, 37, 47};  // 元素为: 26 37 47 0 0 0
```

前 $3$ 个元素具有初始化列表中的值。后 $3$ 个元素的值是 $0$。要把所有元素初始化为 $0$，可以仅使用空的初始化列表

```cpp
unsigned int height[6] {};  // 元素为: 0 0 0 0 0 0
```

有时候，我们需要定义其元素不能修改的数组，只需要在类型前面加上关键字 `const`。下面定义了一个 `unsigned int` 常量的数组

```cpp
const unsigned int height[6] {26, 37, 47, 55, 62, 75};  // 常量的数组
```

编译器将阻止修改这 $6$ 个数组元素中的任何一个（无论赋值、递增还是其他修改）。参与算术表达式的数组元素与其他变量一样，可以用下面的语句计算 `height` 数组中前 $3$ 个元素的总和

```cpp
unsigned int sum {};

sum = height[0] + height[1] + height[2];  // 前三个元素的和
```

在表达式中，数组的每个元素可以像普通整数变量那样操作。如前所述，数组元素可以放在赋值运算符的左边，以设置新值，所以可以在赋值语句中把一个元素的值复制给另一个元素，例如

```cpp
height[3] = height[2];  // 拷贝第三个元素的值到第四个元素
```

但是，**不能利用赋值语句把整个数组的所有元素值赋值到另一个数组的元素，只能操作数组中的各个元素**

```cpp
int array1[3] {1, 2, 3};
int array2[3];

array2 = array1;  // error: 不允许对数组名进行赋值
```

因此，要将一个数组的值复制到另一个数组中，就必须一次复制一个值。此时需要使用 **循环**

## 理解循环

**循环** 是一种机制，**允许重复执行一个或一组语句，直到满足指定的条件为止**。循环有两个基本元素：组成循环体的要重复执行的语句或语句块，以及决定何时停止重复循环的循环条件。**将循环体执行一次称为一次迭代**

循环条件有许多不同的形式，通过了控制循环的不同方式。例如，循环条件可以

+ 执行循环，次数为指定的次数
+ 循环一直执行到给定的值超过另一个值为止
+ 循环一直执行到从键盘输入某个字符为止
+ 为一个元素集合中的每个元素执行循环

可以设置循环条件，以适应使用循环的环境。循环有如下变体

+ `for` 循环：**使循环体执行给定的次数**，但有极大的灵活性
+ 基于范围的 `for` 循环：**为一个元素集合中的每个元素执行一次迭代**
+ `while` 循环：只要指定的条件为 `true`，`while` 循环就继续执行。**条件在迭代开始时检查，所以如果条件开始时就是 `false`，就不执行迭代循环**
+ `do-while` 循环：只要给定的条件为 `true`，`do-while` 循环就继续执行。`do-while` 循环与 `while` 循环不同，因为它在迭代结束时检查条件，所以 **`do-while` 循环中的语句至少执行一次**

下面先介绍 `for` 循环的工作原理

## for 循环

`for` 循环主要用于对语句或语句块执行预知的次数，但也可以用于其他方式。可以使用以分号分隔 $3$ 个表达式来控制 `for` 循环，这 $3$ 哥表达式放在关键字 `for` 后的圆括号中

```cpp
for (initialization; condition; iterate)
{
    // 循环体
}
// 下一条语句
```

如下图演示了 `for` 循环的执行逻辑：`initialization` 只在循环的开始处计算一次；接着检查 `condition`，如果它是 `true`，就执行循环语句或语句块；如果循环条件是 `false`，就跳过循环语句，执行循环后面的下一条语句。每次执行了循环语句或语句块后，就计算 `iterate` 表达式。之后，再次检查循环条件，看看是否继续循环

![1763309374425-28064e13251a5305282c7dfa8107f458.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763309374425-28064e13251a5305282c7dfa8107f458.png)

`for` 循环的一般用法中，第一个表达式用于初始化一个计数器，第二个表达式用于检查这个计数器是否达到给定的极限，第三个表达式用于递增或递减这个计数器。例如

```cpp
double reainfall[12] {1.1, 2.8, 3.4, 3.7, 2.1, 2.3, 1.8, 0.0, 0.3, 0.9, 0.7, 0.5};

double copy [12] {};

for (size_t i {}; i < 12; ++i)  // 初始化 i = 0
{
    copy[i] = reainfall[i];  // 拷贝
}
```

第一个表达式把 `i` 定义为 `size_t` 类型，初始化为 $0$。使用 `size_t` 类型的原因在于 `sizeof` 运算符返回的就是 `size_t` 类型的值。通常，`size_t` 类型是某个无符号整数类型的别名，一般用于计算对象的大小和计数。变量 `i` 用于索引数组，所以使用 `size_t` 类型是有意义的。

第二个表达式是循环条件，只要变量 `i` 小于 $12$，循环条件就是 `true`，循环在变量 `i` 小于 $12$ 是继续执行。变量 `i` 等于 $12$ 时，该表达式就是 `false`，所以循环结束。

第三个表达式在每次循环迭代的末尾递增变量 `i`，所以变量 `i` 的值从 $0$ 变到 $1$ 时，就执行把 `rainfall` 中的第 `i` 个元素复制到 `copy` 中的循环语句块

::: tip

`size_t` 并不是内置的基本类型名称，而是标准库定义的一个类型别名。更具体而言，它是某个无符号整数类型的别名，并且足够大，能够容纳编译器支持的任何类型

别名在 `<cstddef>` 标准库以及其他一些模块中定义。但在实际应用中，大多数时候不需要显示包含这个模块，就能使用 `size_t` 别名

:::

::: danger

**编译器不会检查数组索引值是否有效**。程序员需要自己确保引用的元素不会超出数组边界如果使用超出数组有效范围的索引值来存储数据，那么可能会无意中重写内存中的数据，胡总导致 **段错误** 或 **非法访问**。这两个术语的含义是相同的，**指操作系统在检测到未授权的内存访问时引发错误**。无论是哪种情况，程序几乎一定会异常结束

:::

同往常一样，编译器也会忽略 `for` 语句中的所有空白。另外，如果循环体只包含一条语句，花括号就是可选的。因此，可以把前面的 `for` 循环重写如下形式。请注意：**无论如何都将循环体放入花括号中**

```cpp
for (size_t i {}; i < 12; ++i)  // 初始化 i = 0
    copy[i] = reainfall[i];  // 拷贝
```

---

在 `for` 循环的初始化表达式中定义变量是合法的，也非常常见。此外，还有一些重要的意义。循环定义了一个作用域。循环语句或语句块，包括控制循环的任意表达式，都在循环的作用域内。在循环的作用域内声明的任何自动变量，在循环的外部都不存在。因为变量 `i` 在第一个表达式中定义，所以它是循环的局部变量，循环结束时，变量 `i` 就不存在了。

如果希望在循环结束后仍能访问循环控制变量，可以在循环之前定义它，如下所示

```cpp
size_t i {};

for (i = 0; i < 12; ++i)
{
    copy[i] = rainfall[i];
}
// 变量 i 也可以访问
```

接着就可以在循环后访问变量 `i`，此时的值是 $12$。由于变量 `i` 在定义时被初始化为 $0$，所以第一个循环控制表达式是多余的。可以忽略任意循环控制表达式，所以循环可以重写如下

```cpp
size_t i {};
for ( ; i < 12; ++i)
{
    copy[i] = rainfall[i];
}
```

## 避免幻数

上述代码段存在的一个小问题是数组的大小 $12$ 涉及 **幻数**。假设有人新造出 $13$ 个月份 `Undecimber`，需要添加该月份的降雨量值。此时，很可能在增加了 `rainfall` 数组的大小后忘记更新 `for` 循环中使用的 $12$。`bug` 就是这样出现的

更安全的方法是给数组的大小定义一个 `constexpr` 变量，用它替代显式值

```cpp
constexpr size_t size {12};
double rainfall[size] {1.1, 2.8, 3.4, 3.7, 2.1, 2.3, 1.8, 0.0, 0.3, 0.9, 0.7, 0.5};
double copy [size] {};

for (size_t i {}; i < size; ++i)
{
    copy[i] = rainfall[i];
}
```

这样就不容易出错了，显然，`size` 是指两个数组中元素的个数

::: tip

注意：如果同一个常量值分散在代码的不同地方，很容易忘记在某些地方进行更新，从而导致出错。因此，只应该定义幻数或任何常量一次。如果之后需要修改常量，只需要在一个地方进行修改

:::

下面在一个完整的例子中使用 `for` 循环

```cpp {23-24}
import <iostream>;

int main()
{
    constexpr unsigned size {6};
    unsigned height[size] {26, 37, 47, 55, 62, 75};

    // 计算 height 的总和
    unsigned total {};
    for (size_t i {}; i < size; ++i)
    {
        total += height[i];
    }

    // 计算平均值
    const unsigned average {total / size};
    std::cout << "The average height is " << average << std::endl;

    // 计算身高低于平均身高的人数
    unsigned count {};
    for (size_t i {}; i < size; ++i)
    {
        if (height[i] < average)
            ++count;
    }
    std::cout << count << " people are below average height." << std::endl;
}
```

输出如下

```shell
The average height is 50
3 people are below average height.
```

可以使用下面的语句替换上面的 `if` 语句

```cpp
count += height[i] < average;
// height[i] < average ==> true ==> 1
// height[i] < average ==> false ==> 0
```

这个表达式是有效的，因为比较运算符返回的 `bool` 类型会被隐式转换为 `int` 类型。值 `true` 被转换为 $1$，值 `false` 被转换为 $0$，所以 `count` 仅在比较结果为 `true` 时递增

## 用初始列表定义数组大小

在数组定义中提供初始列表，就可以忽略数组的大小，编译器会自动计算初始列表中元素的个数。例如

```cpp
int values[] {2, 3, 4};
```

这条语句定义了一个数组，它包含了 $3$ 个 `int` 类型的元素，其初始值分别为 $2$、$3$ 和 $4$。该语句等价于

```cpp
int values[3] {2, 3, 4};
```

让编译器自动计算数组大小的优点是，数组的大小不会出错。

### 确定数组的大小

前面介绍了如何定义一个常量来初始化数组的大小，从而避免给数组的元素个数使用幻数。让编译器根据初始化列表确定元素个数时，也不希望给数组的大小指定幻数。在必要时，需要一种确定数组大小的验证方法

最简单也是推荐使用的方法是使用标准库的 `<array>` 模块中提供的 `std::size()` 函数。假设定义下面的数组

```cpp
int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
```

然后，就可以使用 `std::size(values)` 表达式来获得数组 `vlaues` 的大小。函数 `std::size()` 使用非常方便，因此在 C++17 标准中添加到标准库的

::: tip

`std::size()` 函数不只用于数组，还可以用来获得标准库定义的任何元素集合的大小，包括后面介绍的 `std::vector<T>` 和 `std::array<T>` 容器

:::

在 C++17 标准之前，通常是基于 `sizeof` 运算符计算数组的大小。在 [第二章 基本数据类型#整型的尺寸](002-基本数据类型.md#整型的尺寸) 中介绍过，`sizeof` 运算符返回变量占用的字节数，它适用于整个数组和单个数组元素。因此，`sizeof` 运算符提供了确定数组中元素个数的方法：**只需要用数组的大小除以单个元素的大小即可**

```cpp
import <iostream>;
import <array>;

int main()
{
    int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    std::cout << "There are " << std::size(values) << " elements in the array.\n";  // [!code highlight]

    int sum {};
    const size_t array_size = sizeof(values) / sizeof(values[0]); // [!code highlight]
    for (size_t i {}; i < array_size; ++i)
    {
        sum += values[i];
    }
    std::cout << "The sum of the array elements is " << sum << std::endl;
}
```

这个示例的输出如下

```shell
There are 10 elements in the array.
The sum of the array elements is 129
```

编译器会通过数组定义中初始值的数量来确定 `values` 数组的元素个数。在第一个输出语句中使用了 `std::size()` 函数计算数组 `values` 的大小。对于 `array_size` 变量，使用了 `sizeof` 运算符计算数组元素个数，这样做不清楚也不简单。

为了简化使用 `sizeof` 运算符计算数组元素个数，可以定义一个 **函数式宏**。例如

```cpp
import <iostream>;
import <array>;

#define SIZE(array) (sizeof((array)) / sizeof((array)[0]))  // [!code focus]

int main()
{
    int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    std::cout << "There are " << std::size(values) << " elements in the array.\n";

    int sum {};
    constexpr size_t array_size = SIZE(values);  // [!code focus]
    for (size_t i {}; i < array_size; ++i)
    {
        sum += values[i];
    }
    std::cout << "The sum of the array elements is " << sum << std::endl;
}
```

显然，使用 `std::size()` 函数更容易理解。因此，只要有可能，总是使用 `std::size()` 函数；当然，也可以使用 `std::array<T>` 对象

## 用浮点数控制 for 循环

前面使用 `for` 循环的例子都是使用整型变量控制循环，但通常还可以使用自己喜欢的变量控制循环。下面的代码段就使用了浮点数控制循环

```cpp
for (double radius {2.5}; radius <= 20.0; radius += 2.5)
{
    std::cout << std::format("radius = {:4.1f}, area = {:7.2f}\n", radius, std::numbers::pi * radius * radius);
}
```

这个循环用 `radius` 变量控制，其类型是 `double`。它的初始值是 $2.5$，每次循环迭代时都会递增，直到其值超过 $20.0$ 为止，此时循环结束。循环语句利用标准公式 $\pi r^2$，根据 `radius` 变量的当前值计算圆的面积。

::: warning

在使用浮点变量控制 `for` 循环时应小心。小数部分的值可能不能用二进制浮点数准确表示，这会导致一些意想不到的负面效果

:::

## 更复杂的 for 循环控制表达式

在第一个 `for` 循环控制表达式中可以定义并初始化多个给定类型的变量。各个变量之间使用逗号隔开

```cpp
for (unsigned long long n {1}, sum {}, factorial {1}; n <= limit; ++n)
{
    sum += n;  // 1 ... limit 的和
    factorial *= n; // limit!
}
```

注意：在确定变量 `limit` 的值时，请不要使用太大的值，因为阶乘增长会非常快，很容易超出 `unsigned long long` 整数变量的范围。

### 逗号运算符

尽管逗号看起来像是一个分隔符，但实际上它是一个二元运算符。它可以把两个表达式组合到一个表达式中，组合后的表达式的结果是其右操作数的结果。也就是说，只要能编写表达式，就可以编写逗号隔开的一组表达式

```cpp
int i {1};
int value1 {1};
int value2 {1};
int value3 {1};

std::cout << (value1 += ++i, vlaue2 += ++i, value3 += ++i) << std::endl;  // [!code highlight]
// value1 += ++i  ==> i = 2; value1 = 3
// value2 += ++i  ==> i = 3; value2 = 4
// value3 += ++i  ==> i = 4; value3 = 5
```

## 基于范围的 for 循环

基于范围的 `for` 循环迭代一个值范围中的所有值。这会出现一个问题：范围是什么？数组是一个元素范围，字符串是一个字符范围。标准库提供的容器都是范围。基于范围的 `for` 循环的一般形式如下

```cpp
for (range_declaration: range_expression)
{
    // 循环语句或语句块
}
```

`range_expression` 标识数据源的范围，`range_declaration` 标识了一个变量，它会被依次赋予范围中的每个值，在每次迭代时都会赋予一个新值。例如

```cpp
int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

int total {};

for (int x : values)
{
    total += x;
}
```

变量 `x` 在每次迭代中都会被赋予 `values` 数组中的一个值。它会依次被赋予 $2$、$3$、$5$ 等，因此，循环会在 `total` 中累计 `values` 数组中的所有元素的和。变量 `x` 是循环的局部变量，在循环的外部不存在。

**初始化列表本身就是一个有效的范围**，所以甚至可以将前面的代码更简洁的编写如下代码

```cpp
int total {};

for (int x : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})
{
    total += x;
}
```

当然，编译器知道 `values` 数组中的元素的类型，所以可以编写如下循环，让编译器确定变量 `x` 的类型

```cpp
for (auto x : values)
{
    total += x;
}
```

::: tip

使用 `auto` 关键字会让编译器推断 `x` 的类型。`auto` 关键字在基于范围的 `for` 循环中非常常见。这是迭代数组或者其他范围中所有元素的一种非常好的方式。不需要知道元素的个数，循环机制会自动确定

:::

注意范围中的值被赋予范围变量 `x`，这表示不能通过修改 `x` 的值来修改 `values` 数组的元素。例如

```cpp
for (auto x : values)
{
    x += 2;  // 这只是给局部变量 x 加 2，不是给数组元素加 2
}
```

存储在 `x` 中的值会被下一次迭代时被 `values` 数组中的下一个元素值覆盖。在 [第六章 指针和引用](006-指针和引用.md) 中介绍如何使用一个引用变量修改基于范围的 `for` 循环中的值

## while 循环

`while` 循环使用逻辑表达式来控制循环体的执行。该循环的一般形式如下

```cpp
while (condition)
{
    // 循环语句或语句块
}
// 下一条语句
```

下图描述了 `while` 循环的逻辑的执行流程

![1763424983237-d496c5210f1a4abf795cdddfb6e10f6c.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763424983237-d496c5210f1a4abf795cdddfb6e10f6c.png)

在每次循环迭代开始时计算 `condition` 表达式的值。如果 `condition` 的值是 `true`，就继续执行循环体；如果 `condition` 的值为 `false`，就退出循环执行下一条语句。例如

```cpp{19-24} title="sum_factorial.cpp"
import <iostream>;
import <format>;

int main()
{
    unsigned int limit {};
    std::cout << "This program calculates n! and the sum of the integers "
            << "up to n for values 1 to limit.\n";
    std::cout << "What upper limit for n would you like? ";
    std::cin >> limit;

    const auto table_format = "{:>8} {:>8} {:>20}\n"
    std::cout << std::format(table_format, "integer", "sum", "factorial");

    unsigned int n {};
    unsigned int sum {};
    unsigned long long factorial {1ULL};

    while (++n <= limit)
    {
        sum += n;
        factorial *= n;
        std::cout << std::format(table_format, n, sum, factorial);
    }
}
```

::: tip

任何 `for` 循环都可以写为等价的 `while` 循环。例如 `for` 循环的一般形式如下

```cpp
for (initialization; condition; iteration)
{
    // 循环体
}
```

使用 `while` 循环的等价形式为

```cpp
{
    initialization;
    while (condition)
    {
        // 循环体
        iteration
    }
}
```

需要把 `while` 循环放在一个额外的花括号中，从而模拟在原来 `for` 循环中，`initialization` 代码中声明的变量的作用域为该 `for` 循环

:::

## do-while 循环

`do-while` 循环与 `while` 循环类似，区别在于：**`do-while` 循环的循环条件是在循环执行后才检查的**，而不是在开始时检查，所以 **循环语句至少执行一次**。`do-while` 循环的一般形式如下

```cpp
do {
    // 循环体
} while(condition);  // 注意：这里必须有个分号

// 下一条语句
```

`do-while` 循环的循环条件之后必须有一个分号。如果遗漏了它，程序就会编译失败。下图演示了 `do-while` 语句的执行流程

![1763483485831-d6e3ebf63661c77d7ce1a5c2aa062e8f.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763483485831-d6e3ebf63661c77d7ce1a5c2aa062e8f.png)

如果代码块总是要执行一次，也可以执行多次，那么使用 `do-while` 循环再合适不过了。如下例子：程序要计算任意多个输入值的平均值，例如温度，但不对这些值进行排序。实现无法知道要输入多少个值，但是程序可以假定至少会输入一个值，否则程序根本不用执行。此时，最好使用 `do-while` 循环

```cpp title="average.cpp"
import <iostream>;

int main()
{
    char reply {};
    int count {};
    double temperature {};
    double total {};

    do {
        std::cout << "Enter a temperature reading: ";
        std::cin >> temperature;
        total += temperature;
        ++count;

        std::cout << "Do you want to enter another? (y/n): ";
        std::cin >> reply;
    } while (std::tolower(reply) == 'y');
    std::cout << "The average temperature is " << total / count << std::endl;
}
```

::: warning

警告: 不要在 `while` 循环的 `while ()` 后面加上分号

```cpp
while (condition) ;  // 这个分号是一个空语句，这样会导致 while 执行空语句，body 变为 while 循环后的语句
    body
```

如果在 `while` 循环的 `while ()` 后面加上分号，会导致 `while` 执行空语句，`body` 变为 `while` 循环的后的下一条的语句

:::

## 嵌套的循环

可以把一个循环放在另一个循环的内部。实际上，可以在循环中嵌套多次，直到解决问题为止。而且，嵌套的循环可以是任何类型：如有必要，可以在 `while` 循环中嵌套 `for` 循环，再把 `while` 循环嵌套在 `do-while` 循环中，最后把 `do-while` 循环嵌套在基于范围的  `for` 循环中。它们能够以任何方式混合在一起。

嵌套的循环常应用于数组，但它们也有其他用途。下面的示例程序用于 **输出乘法表**，这是嵌套循环的一个非常有用的示例。乘法表如下所示

```shell
1 * 1 = 1
1 * 2 = 2  2 * 2 = 4
1 * 3 = 3  2 * 3 = 6   3 * 3 = 9
1 * 4 = 4  2 * 4 = 8   3 * 4 = 12  4 * 4 = 16
1 * 5 = 5  2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25
1 * 6 = 6  2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36
1 * 7 = 7  2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49
1 * 8 = 8  2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64
1 * 9 = 9  2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81
```

我们需要编写程序输出上述乘法表，要求每列之间的最小间隙是相同。下面给出如下示例代码

```cpp title="multiply_table.cpp"
import <iostream>;
import <format>;


int main()
{
    for (int i = 1; i < 10; ++i) {
        for (int j = 1; j <= i; ++j) {
            if (j < 2)
                std::cout << std::format("{} * {} = {:<3}", j, i, i * j);
            else
                std::cout << std::format("{} * {} = {:<4}", j, i, i * j);
        }
        std::cout << std::endl;
    }
}
```

`for` 循环语句是最容易进行嵌套的。理解 `for` 循环的嵌套，对于其他循环的相互嵌套是同样的

## 跳过循环迭代

有时需要 **跳过循环迭代**，直接开始下一次循环。在需要跳过循环迭代的代码位置输入语句 `continue;`，当循环执行到该语句时，就会立即跳到当前迭代的末尾。只要循环控制表达式允许，程序就会执行下一次迭代。

下面我们用一个示例程序演示 `continue` 语句。假定要输出一个字符表以及对应的十六进制和十进制格式的字符代码。当然，不希望输出没有符号表示的字符(非打印字符)，例如制表符和换行符，这些字符会使结果变得混乱。所以，该示例程序只输出可打印字符

```cpp title="character.cpp"
import <iostream>;
import <format>;
#include <cctype>


int main() {
    // 宽度 11 居中对齐
    constexpr auto head_format = "{:^11}{:^11}{:^11}\n";

    std::cout << std::format(head_format, "Character", "Hexadecimal", "Decimal");

    char ch {};
    do {
        // 字符原样 字符的十六进制编码 字符的十进制编码 输出
        constexpr auto body_format = "{0:^11}{0:^11X}{0:^11d}\n";
        // 不是可打印字符
        if (!std::isprint(ch))
            continue;
        std::cout << std::format(body_format, ch);
    } while (ch++ < 127);
}
```

## 循环中断

有时候需要 **提前终止循环**。当循环没有必要继续执行代码时，就可以使用 `break` 语句提前终止循环。`break` 语句的作用与 [第四章 决策#switch 语句](./004-决策.md#switch-语句) 中的相同。如果在循环中执行 `break` 语句，循环就会立即终止，程序将继续执行循环语句后面的语句。**break 语句在无限循环(indefinite loop)中经常使用**

### 无限循环

无限循环是可以永远执行下去，也称为 **死循环**。例如，如果省略 `for` 循环语句中的第二个控制表达式，循环就没有停止机制了。除非在循环体中采用某种方式退出循环，否则循环会无休止的运行下去

无限循环确实与一些非常有用的应用场景。例如，**监视某种告警指示器程序**，或者在工业园区中收集传感器的数据，有时候就是用无限循环编写的。**在事前不知道需要迭代多少次**时，也可以使用无限循环，例如读取输入数据量可变时。在这些情况下，**退出循环的机制应该在循环体中编写**，而不应该在循环控制表达式中设置

在 `for` 无限循环的最常见形式中，所有的循环控制表达式都被省略了

```cpp
for ( ; ; )
{
    ...
    // 满足条件时退出
    if (condition)
        break; // 或者 return;
}
```

::: tip

在 C/C++ 中，`for` 循环即使没有控制表达式，其中的分号(`;`)也是必须要要保留的。

:::


也可以使用下面的 `while` 无限循环

```cpp
while (true)
{
    ...
    if (condition)
        break; // 或者 return;
}
```

在编写无限循环时，通常使用 `for` 循环或 `while` 循环。当然，`do-while` 循环也可以执行无限循环，但是形式不太好用，也不会经常使用它。无限循环的终止方式之一就是使用 `break` 语句

::: tip

一般而言，应该谨慎使用无限循环，甚至是 `break` 语句。它们有时候被认为是不良的编程风格。尽可能将决定循环合适结束的条件放在循环控制表达式中。

:::

在下面的一个示例中，使用 `while` 无限循环按升序对数组内容进行排序

```cpp {41-47} title="sort.cpp"
import <iostream>;
import <format>;

int main()
{
    constexpr size_t size{ 1000 };  // 数组大小
    double x[size]{};  // 数组
    size_t count{};  // 元素个数

    while (true)
    {
        double input{};
        std::cout << "Enter a non-zero value, or 0 to end: ";
        std::cin >> input;
        if (input == 0.0)
        {
            break;
        }
        x[count++] = input;
        if (count == size)
        {
            std::cout << "Sorry, I can only store " << size << " values.\n";
            break;
        }
    }

    if (count == 0)
    {
        std::cout << "Noting to sort ..." << std::endl;
        return 0;
    }
    std::cout << "Starting sort ..." << std::endl;

    while (true)
    {
        bool swapped{ false };  // 变为 true 时，有元素交换

        for (size_t i{}; i < count - 1; i++)
        {
            // 前一个比后一个小
            if (x[i] > x[i + 1])
            {
                const auto temp = x[i];
                x[i] = x[i + 1];
                x[i + 1] = temp;
                swapped = true;
            }
        }
        // swapped 为 false 表明没有元素发生交换，因此退出循环
        if (!swapped)
        {
            break;
        }
    }
    std::cout << "Your data in ascending sequence: " << std::endl;
    const size_t perline{ 10 };  // 每行输出 perline 个元素
    size_t n{}; // 当前行输出的元素个数
    for (size_t i{}; i < count; ++i)
    {
        std::cout << std::format("{:8.1f}", x[i]);
        if (++n == perline)
        {
            std::cout << std::endl;
            n = 0;
        }
    }
    std::cout << std::endl;
    return 0;
}
```

在上述代码中，我们在 `while` 无限循环中排序元素。对数组元素值排序是在嵌套的 `for` 循环中完成的，该 `for` 循环迭代连续两个元素，检查它们的是否按升序排列。如果两个元素的值不按升序排列，则交换它们的值，使它们正确排序。布尔变量 `swapped` 用于记录在每次执行嵌套的 `for` 循环时是否有数据交换。如果没有数据交换，就证明所有的元素都是排序好的，此时，就应该结束 `while` 无限循环

::: tip

这种排序方法被称为 **冒泡排序**，因为元素逐渐冒泡到数组中正确的位置。虽然，这个排序方法不是高效的，但是用于描述嵌套循环非常有用

:::

## 使用无符号整数控制 for 循环

在 `sort.cpp` 示例代码中，它说明了使用无符号整数控制 `for` 循环的一个要点。这个示例中，检查用户是否输入了值

```cpp
if (count == 0)
{
    std::cout << "Noting to sort ..." << std::endl;
    return 0;
}
```

如果省略上述代码片段。并且用户没有输入值。换句话说，就是 `count == 0`。此时，如果执行到如下循环会发生什么呢？

```cpp
for (size_t i{}; i < count - 1; i++)
{
    // 前一个比后一个小
    if (x[i] > x[i + 1])
    {
        const auto temp = x[i];
        x[i] = x[i + 1];
        x[i + 1] = temp;
        swapped = true;
    }
}
```

如果 `count` 等于 $0$，那么 `count - 1` 的值就是 $-1$。由于 `count` 是无符号整数，编译器会将 $-1$ 的二进制表示解释为无符号整数，因此该值会非常大。即使是最快的计算机也要执行很久才能完成。然而，在我们的示例中，循环计数变量 `i` 在大于 $1000$ 时，`x[i]` 就会访问并覆盖不应该访问的内存地址

::: tip

在进入循环之前，检查 `count` 是否不为 $0$。这就是我们在 `sort.cpp` 示例代码中的解决方案。当然，我们也可以**反向遍历数组**。

:::

## 字符数组

