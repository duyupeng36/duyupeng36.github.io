---
title: 数组和循环
createTime: 2025/11/16 22:17:52
permalink: /cppstudy/zot30i85/
tags:
  - C/C++
---

**数组** 允许用单个名称(数组名)处理类型相同的几个数据项。这是一个非常常见的需求，例如，处理一组温度值或者一组人的年龄。**循环** 是编程中的另一个基本要素。它允许对一个或多个语句重复执行应用程序需要的次数

## 数组

前面创建的所有变量都可以存储指定类型的一个数据项，例如整数、浮点值、字符、布尔值等。**数组可以存储相同类型的多个数据项**。可以创建整数数组或者字符数组，**实际上，可以创建任何数据类型的数组，只要有可用的内存，数组就可以存储任何类型的数据**

数组表示一系列内存空间的变量，每个内存空间都可以存储相同类型的一个数据项。例如，假定编写了一个程序，用来计算一年温度的平均值。现在要扩展这个程序，计算比该平均值高的温度有多少个，比该平均值低的温度有多少个。此时，需要保存初始的示例数据，但在一个变量中存储每个数据项，程序就会很烦恼，而且不切实可行。使用数组就可以很轻松地完成这个任务。例如

```cpp
double temperatures[366];  // 定义一个长度为 366 的 double  类型的数组 temperatures
```

这个语句定义了一个 `double` 类型的数组，其名称是 `temperatures`，有 $366$ 个值。把数据值称为 **元素**，把在方括号中指定的元素个数称为 **数组的大小**。数组元素没有在这个语句中初始化，所以它们包含垃圾值。

**数组的大小必须用常量整数表达式来指定**。编译器在编译时能够计算的任何整数表达式都可以用于指定数组大小，不过最常用的整数字面值，或者使用字面值进行初始化的 `constexpr` 整型变量

使用一个整数可以引用数组元素，把该整数称为 **数组的索引**。**数组元素的索引是指该元素与数组第一个元素的偏移值**。第一个元素的偏移值是 $0$，因此其索引是 $0$，索引值为 $3$ 表示数组中的第 $4$ 个元素(与第一个元素偏移 $3$ 个元素)。要引用元素，可以在数组名后面的方括号中放置其索引。要把 `temperatures` 数组的第 $4$ 个元素设置为 $99.0$，可以使用如下语句

```cpp
temperatures[3] = 99.0;  // 设置第四个元素为 99.0
```

为了更好的说明数组，来看下面一个数组的定义

```cpp
unsigned int height[6];  // 定义一个长度为 6 的数组 height
```

在执行这个定义语句时，编译器为这 $6$ 个 `unsigned int` 类型的值分配 $6$ 个连续的存储位置。`height` 数组中的每个元素都包含不同的值。因为 `height` 数组的定义没有为数组指定初始值，所以其元素包含的垃圾值(类似于创建一个 `unsigned int` 类型的变量，但不为其指定的初始值)。下面的语句定义了带初始值的数组

```cpp
unsigned int height[6] {26, 37, 47, 55, 62, 75}; // 定义并初始化长度为 6 的数组
```

初始化列表包含 $6$ 个用逗号隔开的值。这些值可能是某个家庭中所有成员的身高，其单位是英寸。每个数组元素都按顺序被赋予列表中的一个初始值，所以元素具有如下图所示的值

![1763307080799-38fd35eb3037375beb8f687ad1515f9e.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763307080799-38fd35eb3037375beb8f687ad1515f9e.png)

上图中每个框都表示保存数组元素的一个内存位置。该数组中有 $6$ 个元素，其索引是 $0$(表示第一个元素)到 $5$(表示最后一个元素)。每个元素都可以通过上面的表达式来引用

::: warning

数组的类型决定了存储每个数组元素所需要的内存量。数组的所有元素都存储在一个连续的内存块中。因此，如果 `unsigned int` 类型的值在计算机中需要 $4$ 字节，则 `height` 数组就需要占用 $24$ 字节

:::

**初始化列表中值的个数不能超过数组的元素个数**，否则该语句不会编译。初始化列表中值的个数可以少于数组的元素个数，此时没有提供初始值的元素就初始化为 $0$(对于 `bool` 元素数组则为 `false`)

```cpp
unsigned int height[6] {26, 37, 47};  // 元素为: 26 37 47 0 0 0
```

前 $3$ 个元素具有初始化列表中的值。后 $3$ 个元素的值是 $0$。要把所有元素初始化为 $0$，可以仅使用空的初始化列表

```cpp
unsigned int height[6] {};  // 元素为: 0 0 0 0 0 0
```

有时候，我们需要定义其元素不能修改的数组，只需要在类型前面加上关键字 `const`。下面定义了一个 `unsigned int` 常量的数组

```cpp
const unsigned int height[6] {26, 37, 47, 55, 62, 75};  // 常量的数组
```

编译器将阻止修改这 $6$ 个数组元素中的任何一个（无论赋值、递增还是其他修改）。参与算术表达式的数组元素与其他变量一样，可以用下面的语句计算 `height` 数组中前 $3$ 个元素的总和

```cpp
unsigned int sum {};

sum = height[0] + height[1] + height[2];  // 前三个元素的和
```

在表达式中，数组的每个元素可以像普通整数变量那样操作。如前所述，数组元素可以放在赋值运算符的左边，以设置新值，所以可以在赋值语句中把一个元素的值复制给另一个元素，例如

```cpp
height[3] = height[2];  // 拷贝第三个元素的值到第四个元素
```

但是，**不能利用赋值语句把整个数组的所有元素值赋值到另一个数组的元素，只能操作数组中的各个元素**

```cpp
int array1[3] {1, 2, 3};
int array2[3];

array2 = array1;  // error: 不允许对数组名进行赋值
```

因此，要将一个数组的值复制到另一个数组中，就必须一次复制一个值。此时需要使用 **循环**

## 理解循环

**循环** 是一种机制，**允许重复执行一个或一组语句，直到满足指定的条件为止**。循环有两个基本元素：组成循环体的要重复执行的语句或语句块，以及决定何时停止重复循环的循环条件。**将循环体执行一次称为一次迭代**

循环条件有许多不同的形式，通过了控制循环的不同方式。例如，循环条件可以

+ 执行循环，次数为指定的次数
+ 循环一直执行到给定的值超过另一个值为止
+ 循环一直执行到从键盘输入某个字符为止
+ 为一个元素集合中的每个元素执行循环

可以设置循环条件，以适应使用循环的环境。循环有如下变体

+ `for` 循环：**使循环体执行给定的次数**，但有极大的灵活性
+ 基于范围的 `for` 循环：**为一个元素集合中的每个元素执行一次迭代**
+ `while` 循环：只要指定的条件为 `true`，`while` 循环就继续执行。**条件在迭代开始时检查，所以如果条件开始时就是 `false`，就不执行迭代循环**
+ `do-while` 循环：只要给定的条件为 `true`，`do-while` 循环就继续执行。`do-while` 循环与 `while` 循环不同，因为它在迭代结束时检查条件，所以 **`do-while` 循环中的语句至少执行一次**

下面先介绍 `for` 循环的工作原理

## for 循环

`for` 循环主要用于对语句或语句块执行预知的次数，但也可以用于其他方式。可以使用以分号分隔 $3$ 个表达式来控制 `for` 循环，这 $3$ 哥表达式放在关键字 `for` 后的圆括号中

```cpp
for (initialization; condition; iterate)
{
    // 循环体
}
// 下一条语句
```

如下图演示了 `for` 循环的执行逻辑：`initialization` 只在循环的开始处计算一次；接着检查 `condition`，如果它是 `true`，就执行循环语句或语句块；如果循环条件是 `false`，就跳过循环语句，执行循环后面的下一条语句。每次执行了循环语句或语句块后，就计算 `iterate` 表达式。之后，再次检查循环条件，看看是否继续循环

![1763309374425-28064e13251a5305282c7dfa8107f458.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763309374425-28064e13251a5305282c7dfa8107f458.png)

`for` 循环的一般用法中，第一个表达式用于初始化一个计数器，第二个表达式用于检查这个计数器是否达到给定的极限，第三个表达式用于递增或递减这个计数器。例如

```cpp
double reainfall[12] {1.1, 2.8, 3.4, 3.7, 2.1, 2.3, 1.8, 0.0, 0.3, 0.9, 0.7, 0.5};

double copy [12] {};

for (size_t i {}; i < 12; ++i)  // 初始化 i = 0
{
    copy[i] = reainfall[i];  // 拷贝
}
```

第一个表达式把 `i` 定义为 `size_t` 类型，初始化为 $0$。使用 `size_t` 类型的原因在于 `sizeof` 运算符返回的就是 `size_t` 类型的值。通常，`size_t` 类型是某个无符号整数类型的别名，一般用于计算对象的大小和计数。变量 `i` 用于索引数组，所以使用 `size_t` 类型是有意义的。

第二个表达式是循环条件，只要变量 `i` 小于 $12$，循环条件就是 `true`，循环在变量 `i` 小于 $12$ 是继续执行。变量 `i` 等于 $12$ 时，该表达式就是 `false`，所以循环结束。

第三个表达式在每次循环迭代的末尾递增变量 `i`，所以变量 `i` 的值从 $0$ 变到 $1$ 时，就执行把 `rainfall` 中的第 `i` 个元素复制到 `copy` 中的循环语句块

::: tip

`size_t` 并不是内置的基本类型名称，而是标准库定义的一个类型别名。更具体而言，它是某个无符号整数类型的别名，并且足够大，能够容纳编译器支持的任何类型

别名在 `<cstddef>` 标准库以及其他一些模块中定义。但在实际应用中，大多数时候不需要显示包含这个模块，就能使用 `size_t` 别名

:::

::: danger

**编译器不会检查数组索引值是否有效**。程序员需要自己确保引用的元素不会超出数组边界如果使用超出数组有效范围的索引值来存储数据，那么可能会无意中重写内存中的数据，胡总导致 **段错误** 或 **非法访问**。这两个术语的含义是相同的，**指操作系统在检测到未授权的内存访问时引发错误**。无论是哪种情况，程序几乎一定会异常结束

:::

同往常一样，编译器也会忽略 `for` 语句中的所有空白。另外，如果循环体只包含一条语句，花括号就是可选的。因此，可以把前面的 `for` 循环重写如下形式。请注意：**无论如何都将循环体放入花括号中**

```cpp
for (size_t i {}; i < 12; ++i)  // 初始化 i = 0
    copy[i] = reainfall[i];  // 拷贝
```

---

在 `for` 循环的初始化表达式中定义变量是合法的，也非常常见。此外，还有一些重要的意义。循环定义了一个作用域。循环语句或语句块，包括控制循环的任意表达式，都在循环的作用域内。在循环的作用域内声明的任何自动变量，在循环的外部都不存在。因为变量 `i` 在第一个表达式中定义，所以它是循环的局部变量，循环结束时，变量 `i` 就不存在了。

如果希望在循环结束后仍能访问循环控制变量，可以在循环之前定义它，如下所示

```cpp
size_t i {};

for (i = 0; i < 12; ++i)
{
    copy[i] = rainfall[i];
}
// 变量 i 也可以访问
```

接着就可以在循环后访问变量 `i`，此时的值是 $12$。由于变量 `i` 在定义时被初始化为 $0$，所以第一个循环控制表达式是多余的。可以忽略任意循环控制表达式，所以循环可以重写如下

```cpp
size_t i {};
for ( ; i < 12; ++i)
{
    copy[i] = rainfall[i];
}
```

## 避免幻数

上述代码段存在的一个小问题是数组的大小 $12$ 涉及 **幻数**。假设有人新造出 $13$ 个月份 `Undecimber`，需要添加该月份的降雨量值。此时，很可能在增加了 `rainfall` 数组的大小后忘记更新 `for` 循环中使用的 $12$。`bug` 就是这样出现的

更安全的方法是给数组的大小定义一个 `constexpr` 变量，用它替代显式值

```cpp
constexpr size_t size {12};
double rainfall[size] {1.1, 2.8, 3.4, 3.7, 2.1, 2.3, 1.8, 0.0, 0.3, 0.9, 0.7, 0.5};
double copy [size] {};

for (size_t i {}; i < size; ++i)
{
    copy[i] = rainfall[i];
}
```

这样就不容易出错了，显然，`size` 是指两个数组中元素的个数

::: tip

注意：如果同一个常量值分散在代码的不同地方，很容易忘记在某些地方进行更新，从而导致出错。因此，只应该定义幻数或任何常量一次。如果之后需要修改常量，只需要在一个地方进行修改

:::

下面在一个完整的例子中使用 `for` 循环

```cpp {23-24}
import <iostream>;

int main()
{
    constexpr unsigned size {6};
    unsigned height[size] {26, 37, 47, 55, 62, 75};

    // 计算 height 的总和
    unsigned total {};
    for (size_t i {}; i < size; ++i)
    {
        total += height[i];
    }

    // 计算平均值
    const unsigned average {total / size};
    std::cout << "The average height is " << average << std::endl;

    // 计算身高低于平均身高的人数
    unsigned count {};
    for (size_t i {}; i < size; ++i)
    {
        if (height[i] < average)
            ++count;
    }
    std::cout << count << " people are below average height." << std::endl;
}
```

输出如下

```shell
The average height is 50
3 people are below average height.
```

可以使用下面的语句替换上面的 `if` 语句

```cpp
count += height[i] < average;
// height[i] < average ==> true ==> 1
// height[i] < average ==> false ==> 0
```

这个表达式是有效的，因为比较运算符返回的 `bool` 类型会被隐式转换为 `int` 类型。值 `true` 被转换为 $1$，值 `false` 被转换为 $0$，所以 `count` 仅在比较结果为 `true` 时递增

## 用初始列表定义数组大小

在数组定义中提供初始列表，就可以忽略数组的大小，编译器会自动计算初始列表中元素的个数。例如

```cpp
int values[] {2, 3, 4};
```

这条语句定义了一个数组，它包含了 $3$ 个 `int` 类型的元素，其初始值分别为 $2$、$3$ 和 $4$。该语句等价于

```cpp
int values[3] {2, 3, 4};
```

让编译器自动计算数组大小的优点是，数组的大小不会出错。

### 确定数组的大小

前面介绍了如何定义一个常量来初始化数组的大小，从而避免给数组的元素个数使用幻数。让编译器根据初始化列表确定元素个数时，也不希望给数组的大小指定幻数。在必要时，需要一种确定数组大小的验证方法

最简单也是推荐使用的方法是使用标准库的 `<array>` 模块中提供的 `std::size()` 函数。假设定义下面的数组

```cpp
int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
```

然后，就可以使用 `std::size(values)` 表达式来获得数组 `vlaues` 的大小。函数 `std::size()` 使用非常方便，因此在 C++17 标准中添加到标准库的

::: tip

`std::size()` 函数不只用于数组，还可以用来获得标准库定义的任何元素集合的大小，包括后面介绍的 `std::vector<T>` 和 `std::array<T>` 容器

:::

在 C++17 标准之前，通常是基于 `sizeof` 运算符计算数组的大小。在 [第二章 基本数据类型#整型的尺寸](002-基本数据类型.md#整型的尺寸) 中介绍过，`sizeof` 运算符返回变量占用的字节数，它适用于整个数组和单个数组元素。因此，`sizeof` 运算符提供了确定数组中元素个数的方法：**只需要用数组的大小除以单个元素的大小即可**

```cpp
import <iostream>;
import <array>;

int main()
{
    int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    std::cout << "There are " << std::size(values) << " elements in the array.\n";  // [!code highlight]

    int sum {};
    const size_t array_size = sizeof(values) / sizeof(values[0]); // [!code highlight]
    for (size_t i {}; i < array_size; ++i)
    {
        sum += values[i];
    }
    std::cout << "The sum of the array elements is " << sum << std::endl;
}
```

这个示例的输出如下

```shell
There are 10 elements in the array.
The sum of the array elements is 129
```

编译器会通过数组定义中初始值的数量来确定 `values` 数组的元素个数。在第一个输出语句中使用了 `std::size()` 函数计算数组 `values` 的大小。对于 `array_size` 变量，使用了 `sizeof` 运算符计算数组元素个数，这样做不清楚也不简单。

为了简化使用 `sizeof` 运算符计算数组元素个数，可以定义一个 **函数式宏**。例如

```cpp
import <iostream>;
import <array>;

#define SIZE(array) (sizeof((array)) / sizeof((array)[0]))  // [!code focus]

int main()
{
    int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    std::cout << "There are " << std::size(values) << " elements in the array.\n";

    int sum {};
    constexpr size_t array_size = SIZE(values);  // [!code focus]
    for (size_t i {}; i < array_size; ++i)
    {
        sum += values[i];
    }
    std::cout << "The sum of the array elements is " << sum << std::endl;
}
```

显然，使用 `std::size()` 函数更容易理解。因此，只要有可能，总是使用 `std::size()` 函数；当然，也可以使用 `std::array<T>` 对象

## 用浮点数控制 for 循环

前面使用 `for` 循环的例子都是使用整型变量控制循环，但通常还可以使用自己喜欢的变量控制循环。下面的代码段就使用了浮点数控制循环

```cpp
for (double radius {2.5}; radius <= 20.0; radius += 2.5)
{
    std::cout << std::format("radius = {:4.1f}, area = {:7.2f}\n", radius, std::numbers::pi * radius * radius);
}
```

这个循环用 `radius` 变量控制，其类型是 `double`。它的初始值是 $2.5$，每次循环迭代时都会递增，直到其值超过 $20.0$ 为止，此时循环结束。循环语句利用标准公式 $\pi r^2$，根据 `radius` 变量的当前值计算圆的面积。

::: warning

在使用浮点变量控制 `for` 循环时应小心。小数部分的值可能不能用二进制浮点数准确表示，这会导致一些意想不到的负面效果

:::

## 更复杂的 for 循环控制表达式

在第一个 `for` 循环控制表达式中可以定义并初始化多个给定类型的变量。各个变量之间使用逗号隔开

```cpp
for (unsigned long long n {1}, sum {}, factorial {1}; n <= limit; ++n)
{
    sum += n;  // 1 ... limit 的和
    factorial *= n; // limit!
}
```

注意：在确定变量 `limit` 的值时，请不要使用太大的值，因为阶乘增长会非常快，很容易超出 `unsigned long long` 整数变量的范围。

### 逗号运算符

尽管逗号看起来像是一个分隔符，但实际上它是一个二元运算符。它可以把两个表达式组合到一个表达式中，组合后的表达式的结果是其右操作数的结果。也就是说，只要能编写表达式，就可以编写逗号隔开的一组表达式

```cpp
int i {1};
int value1 {1};
int value2 {1};
int value3 {1};

std::cout << (value1 += ++i, vlaue2 += ++i, value3 += ++i) << std::endl;  // [!code highlight]
// value1 += ++i  ==> value1 = 3; i = 2
// value2 += ++i  ==> value2 = 4; i = 3
// value3 += ++i  ==> value3 = 5; i = 4
```

## 基于范围的 for 循环

