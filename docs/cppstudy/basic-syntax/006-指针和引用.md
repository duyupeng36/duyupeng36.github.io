---
title: 指针和引用
createTime: 2025/11/18 21:17:57
permalink: /cppstudy/pl6nd91k/
---

指针与引用的概念比较相似，因此我们将其放在一起介绍。指针非常重要，是 C++ 语言的核心概念之一，理解指针是学好 C++ 的关键。在 C++ 中，指针与数组的关系也非常紧密，因此我还会站在指针的视角解释数组

## 什么是指针

程序中的每个变量和函数都位于内存的某个地方，所以都有独特的地址来标识它们存储的位置。这些地址取决于运行程序时将程序加载到内存的什么地方，所以程序每次运行时，这些地址都有可能不同。

**指针是可以存储地址的变量**。存储在指针中的地址可以是变量或者其他数据的地址。下图说明了指针这名字的由来：它指向内存中存储其他值的位置

![1763834364485-b92a41a121e7716cb5ccddec8d9f1451.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763834364485-b92a41a121e7716cb5ccddec8d9f1451.png)

正如在 [第二章 基本数据类型](./002-基本数据类型.md) 中介绍的一样，整数的表示方法和浮点数完全不一样。因此，要使用存储于指针所指向的地址数据，还需要知道数据的类型。如果指针仅存储随意数据的内存地址，那么指针就没有什么意义了。因此，**使用指针时需要关注指针指向数据的数据类型**

在 C++ 中，指针的定义与普通变量的定义类似，但是在变量名之前需要加上一个星号(`*`)，表示该变量是一个指针。例如，下面的代码定义了一个指向整数的指针变量 `p`：

```cpp
long *p;  // 指针 p 指向一个 long 类型的数据所在的内存
```

变量 `p` 的类型是 `long*`，表示它是一个指向 `long` 类型数据的指针。注意，`long*` 和 `long` 是两种不同的类型。该类型的变量只能存储 `long` 类型数据的地址。尝试存储其他非 `long` 类型数据的地址会导致编译错误。

::: tip

这里我们我们将星号与指针变量 `p` 紧挨在一起书写，表示在声明指针变量时 **星号是指针变量声明的一部分**，而不是类型的一部分。

:::

看下面的示例

```cpp
long *p, number;
```

这里定义了两个变量 `p` 和 `number`。变量 `p` 是一个指向 `long` 类型数据的指针，而变量 `number` 是一个普通的 `long` 类型变量。注意，只有变量 `p` 是指针类型，变量 `number` 不是指针类型。如果我们将星号(`*`)与类型 `long` 紧挨在一起书写，如下所示：

```cpp
long* p, number;
```

这可能会让人误以为 `p` 和 `number` 都是指针类型，但实际上只有 `p` 是指针类型，`number` 仍然是一个普通的 `long` 类型变量。因此，为了避免混淆，建议将星号(`*`)与指针变量名紧挨在一起书写。**当然最好的方式就一行只声明一个变量**，这样就不会出错

::: danger

注意，这里定义的指针变量 `p` 并没有初始化，它的值是未定义的，指向一个随机的内存地址。在使用指针之前，必须先将其初始化为一个有效的地址，否则会导致程序崩溃。

像这种执行未知地址的指针称为 **“野指针”(wild pointer)**。野指针非常危险，因此我们应该在指针变量被声明时就立即进行初始化。如果不想立即初始化指针变量，可以将其初始化为 `nullptr`，表示该指针不指向任何有效的地址

```cpp
long *p{nullptr};  // 指针 p 不指向任何有效地址
```

在使用指针变量时，请遵守黄金法则: **指针变量声明时立即初始化**

:::

可以把指针定义为任何类型，包括自定义类型。例如

```cpp
double *pvalue{};  // 基本类型

char16_t *pchar {};  // 自定义类型
```

不过，**无论指针指向什么类型或者大小的数据，指针变量本身的大小始终相同**。准确的说，在给定的平台上，所有指针变量都具有相同的大小。指针变量的大小取决于目标平台的可寻址内存的大小。下面的示例代码用于说明这个特性

```cpp title="pointer_size.cpp"
import <iostream>;

int main()
{
    std::cout << "Size of double: " << sizeof(double) << " bytes\n";
    std::cout << "Size of double pointer: " << sizeof(double*) << " bytes\n";
    std::cout << "Size of char: " << sizeof(char) << " bytes\n
    std::cout << "Size of char pointer: " << sizeof(char*) << " bytes\n";
    return 0;
}
```

该示例程序输出的内容为

```shell
Size of double: 8 bytes
Size of double pointer: 8 bytes
Size of char: 1 bytes
Size of char pointer: 8 bytes
```

无论是 `double` 还是 `char` 类型的指针变量，其大小均为 8 字节。这是因为该程序运行在一个 64 位的平台上，该平台的指针变量大小均为 8 字节。

## 地址运算符

地址运算符 `&` 是一个一元运算符，它可以获取变量的地址。例如，下面定义了一个变量 `number` 和一个指针变量 `p`，并将变量 `number` 的地址赋值给指针变量 `p`

```cpp
long number {42};  // 定义一个 long 类型变量 number 并初始化为 42
long *p (&number); // 定义一个指向 long 类型的指针变量 p，并将 number 的地址赋值给 p
```

表达式 `&number` 的值是变量 `number` 的地址，所以 `p` 存储了变量 `number` 的地址。现在，指针变量 `p` 指向变量 `number` 所在的内存位置。当然，也可以使用赋值语句将变量的地址赋值给指针变量

```cpp
long height {1454L};

p = &height;  // 将变量 height 的地址赋值给指针变量 p
```

::: tip

`&` 运算符可以应用于任何类型的变量，但必须在对应类型的指针中存储地址。例如，要存储 `double` 类型变量的地址，必须使用 `double*` 类型的指针变量

:::

当然，也可以使用 `auto` 关键字，让编译器自动推断类型。例如

```cpp

auto p {&number};  // p 的类型被推断为 long*

```

但是，建议使用 `auto *`，以便于在声明中能够清晰看出这里涉及指针。这里通过使用 `auto *`，定义了由编译器推断出来的指针类型的变量

```cpp
auto *p {&number};  // p 的类型被推断为 long*
```

请注意：使用 `auto *` 声明的变量只能使用指针初始化。使用其他类型的值初始化，编译器会报错

变量的地址已经被存储到指针变量中，我们关心的是如何通过地址操作其指向的内存中保存的数据。这可以使用间接运算符完成

## 间接运算符

间接运算符 `*` 应用于指针，可以访问指针所执行的内存位置的数据。间接运算符这个名称来自于数据的访问是间接的这一事实。该运算符也被称为解引用运算符，访问指针所指向的内存位置的数据的过程称为 **解除指针的引用**。要访问指针 `p` 所指向的地址中的数据，可以使用表达式 `*p`。通过如下示例程序来看指针的用法

```cpp title="pointer_example.cpp"
import <iostream>;
import <format>;

int main()
{
    int unit_price{ 295 };
    int count{};
    int discount_threshold{ 25 };
    double discount{ 0.07 };

    int* pcount{ &count };
    std::cout << "Enter the number of items you want: ";
    std::cin >> *pcount;
    std::cout << std::format("The unit price is ${:.2f}.\n", unit_price / 100.0);

    int* punit_price{ &unit_price };
    int price{ *pcount * *punit_price }; // [!code highlight]
    auto* pprice{ &price };

    double net_price{};
    double* pnet_price{ nullptr };
    pnet_price = &net_price;
    if (*pcount > discount_threshold)
    {
        std::cout << std::format("You qualify for a discount of {:.0f} percent.\n", discount * 100);
        *pnet_price = price * (1 - discount) / 100;
    }
    else
    {
        net_price = *pprice / 100;
    }
    std::cout << std::format("The net price for {} item is ${:.2f}.\n", *pcount, net_price);

    return 0;
}
```

该程序的运行结果如下

```shell
Enter the number of items you want: 50
The unit price is $2.95.
You qualify for a discount of 7 percent.
The net price for 50 item is $137.17.
```

表达式 `*pcount * *punit_price` 非常容易混淆。因为，运算符 `*` 有不同的含义。编译器可以根据上下文解析出星号(`*`) 的含义。。为了让代码更容易理解，这里设计多重含义的运算符时，可以使用圆括号，即 `(*pcount) * (*punit_price)`。这样可以清晰地表明这里的星号(`*`) 都是间接运算符。

## char 类型的指针
