---
title: 指针和引用
createTime: 2025/11/18 21:17:57
permalink: /cppstudy/pl6nd91k/
---

指针与引用的概念比较相似，因此我们将其放在一起介绍。指针非常重要，是 C++ 语言的核心概念之一，理解指针是学好 C++ 的关键。在 C++ 中，指针与数组的关系也非常紧密，因此我还会站在指针的视角解释数组

## 什么是指针

程序中的每个变量和函数都位于内存的某个地方，所以都有独特的地址来标识它们存储的位置。这些地址取决于运行程序时将程序加载到内存的什么地方，所以程序每次运行时，这些地址都有可能不同。

**指针是可以存储地址的变量**。存储在指针中的地址可以是变量或者其他数据的地址。下图说明了指针这名字的由来：它指向内存中存储其他值的位置

![1763834364485-b92a41a121e7716cb5ccddec8d9f1451.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763834364485-b92a41a121e7716cb5ccddec8d9f1451.png)

正如在 [第二章 基本数据类型](./002-基本数据类型.md) 中介绍的一样，整数的表示方法和浮点数完全不一样。因此，要使用存储于指针所指向的地址数据，还需要知道数据的类型。如果指针仅存储随意数据的内存地址，那么指针就没有什么意义了。因此，**使用指针时需要关注指针指向数据的数据类型**

在 C++ 中，指针的定义与普通变量的定义类似，但是在变量名之前需要加上一个星号(`*`)，表示该变量是一个指针。例如，下面的代码定义了一个指向整数的指针变量 `p`：

```cpp
long *p;  // 指针 p 指向一个 long 类型的数据所在的内存
```

变量 `p` 的类型是 `long*`，表示它是一个指向 `long` 类型数据的指针。注意，`long*` 和 `long` 是两种不同的类型。该类型的变量只能存储 `long` 类型数据的地址。尝试存储其他非 `long` 类型数据的地址会导致编译错误。

::: tip

这里我们我们将星号与指针变量 `p` 紧挨在一起书写，表示在声明指针变量时 **星号是指针变量声明的一部分**，而不是类型的一部分。

:::

看下面的示例

```cpp
long *p, number;
```

这里定义了两个变量 `p` 和 `number`。变量 `p` 是一个指向 `long` 类型数据的指针，而变量 `number` 是一个普通的 `long` 类型变量。注意，只有变量 `p` 是指针类型，变量 `number` 不是指针类型。如果我们将星号(`*`)与类型 `long` 紧挨在一起书写，如下所示：

```cpp
long* p, number;
```

这可能会让人误以为 `p` 和 `number` 都是指针类型，但实际上只有 `p` 是指针类型，`number` 仍然是一个普通的 `long` 类型变量。因此，为了避免混淆，建议将星号(`*`)与指针变量名紧挨在一起书写。**当然最好的方式就一行只声明一个变量**，这样就不会出错

::: danger

注意，这里定义的指针变量 `p` 并没有初始化，它的值是未定义的，指向一个随机的内存地址。在使用指针之前，必须先将其初始化为一个有效的地址，否则会导致程序崩溃。

像这种执行未知地址的指针称为 **“野指针”(wild pointer)**。野指针非常危险，因此我们应该在指针变量被声明时就立即进行初始化。如果不想立即初始化指针变量，可以将其初始化为 `nullptr`，表示该指针不指向任何有效的地址

```cpp
long *p{nullptr};  // 指针 p 不指向任何有效地址
```

在使用指针变量时，请遵守黄金法则: **指针变量声明时立即初始化**

:::

可以把指针定义为任何类型，包括自定义类型。例如

```cpp
double *pvalue{};  // 基本类型

char16_t *pchar {};  // 自定义类型
```

不过，**无论指针指向什么类型或者大小的数据，指针变量本身的大小始终相同**。准确的说，在给定的平台上，所有指针变量都具有相同的大小。指针变量的大小取决于目标平台的可寻址内存的大小。下面的示例代码用于说明这个特性

```cpp title="pointer_size.cpp"
import <iostream>;

int main()
{
    std::cout << "Size of double: " << sizeof(double) << " bytes\n";
    std::cout << "Size of double pointer: " << sizeof(double*) << " bytes\n";
    std::cout << "Size of char: " << sizeof(char) << " bytes\n
    std::cout << "Size of char pointer: " << sizeof(char*) << " bytes\n";
    return 0;
}
```

该示例程序输出的内容为

```shell
Size of double: 8 bytes
Size of double pointer: 8 bytes
Size of char: 1 bytes
Size of char pointer: 8 bytes
```

无论是 `double` 还是 `char` 类型的指针变量，其大小均为 8 字节。这是因为该程序运行在一个 64 位的平台上，该平台的指针变量大小均为 8 字节。

## 地址运算符

地址运算符 `&` 是一个一元运算符，它可以获取变量的地址。例如，下面定义了一个变量 `number` 和一个指针变量 `p`，并将变量 `number` 的地址赋值给指针变量 `p`

```cpp
long number {42};  // 定义一个 long 类型变量 number 并初始化为 42
long *p (&number); // 定义一个指向 long 类型的指针变量 p，并将 number 的地址赋值给 p
```

表达式 `&number` 的值是变量 `number` 的地址，所以 `p` 存储了变量 `number` 的地址。现在，指针变量 `p` 指向变量 `number` 所在的内存位置。当然，也可以使用赋值语句将变量的地址赋值给指针变量

```cpp
long height {1454L};

p = &height;  // 将变量 height 的地址赋值给指针变量 p
```

::: tip

`&` 运算符可以应用于任何类型的变量，但必须在对应类型的指针中存储地址。例如，要存储 `double` 类型变量的地址，必须使用 `double*` 类型的指针变量

:::

当然，也可以使用 `auto` 关键字，让编译器自动推断类型。例如

```cpp

auto p {&number};  // p 的类型被推断为 long*

```

但是，建议使用 `auto *`，以便于在声明中能够清晰看出这里涉及指针。这里通过使用 `auto *`，定义了由编译器推断出来的指针类型的变量

```cpp
auto *p {&number};  // p 的类型被推断为 long*
```

请注意：使用 `auto *` 声明的变量只能使用指针初始化。使用其他类型的值初始化，编译器会报错

变量的地址已经被存储到指针变量中，我们关心的是如何通过地址操作其指向的内存中保存的数据。这可以使用间接运算符完成

## 间接运算符

间接运算符 `*` 应用于指针，可以访问指针所执行的内存位置的数据。间接运算符这个名称来自于数据的访问是间接的这一事实。该运算符也被称为解引用运算符，访问指针所指向的内存位置的数据的过程称为 **解除指针的引用**。要访问指针 `p` 所指向的地址中的数据，可以使用表达式 `*p`。通过如下示例程序来看指针的用法

```cpp title="pointer_example.cpp"
import <iostream>;
import <format>;

int main()
{
    int unit_price{ 295 };
    int count{};
    int discount_threshold{ 25 };
    double discount{ 0.07 };

    int* pcount{ &count };
    std::cout << "Enter the number of items you want: ";
    std::cin >> *pcount;
    std::cout << std::format("The unit price is ${:.2f}.\n", unit_price / 100.0);

    int* punit_price{ &unit_price };
    int price{ *pcount * *punit_price }; // [!code highlight]
    auto* pprice{ &price };

    double net_price{};
    double* pnet_price{ nullptr };
    pnet_price = &net_price;
    if (*pcount > discount_threshold)
    {
        std::cout << std::format("You qualify for a discount of {:.0f} percent.\n", discount * 100);
        *pnet_price = price * (1 - discount) / 100;
    }
    else
    {
        net_price = *pprice / 100;
    }
    std::cout << std::format("The net price for {} item is ${:.2f}.\n", *pcount, net_price);

    return 0;
}
```

该程序的运行结果如下

```shell
Enter the number of items you want: 50
The unit price is $2.95.
You qualify for a discount of 7 percent.
The net price for 50 item is $137.17.
```

表达式 `*pcount * *punit_price` 非常容易混淆。因为，运算符 `*` 有不同的含义。编译器可以根据上下文解析出星号(`*`) 的含义。。为了让代码更容易理解，这里设计多重含义的运算符时，可以使用圆括号，即 `(*pcount) * (*punit_price)`。这样可以清晰地表明这里的星号(`*`) 都是间接运算符。

## char 类型的指针

指向 `char` 类型的变量有一个有趣的属性，它可以用字符串字面值初始化。例如，下面的语句就声明并初始化了这样一个指针

```cpp
char *pproverb {"A miss is as good as a mile."};  // 不要这样做
```

这条语句看起非常类似于用字符串字面值初始化 `char` 数组，事实也确实如此。这条语句利用引号中的字符串创建了一个以空字符结尾的字符串字面值，并把字符串字面值中第一个字符的地址存储在 `pproverb` 中。如下图

![1763905778452-28beff1d90847bda3985359c69c4b2be.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763905778452-28beff1d90847bda3985359c69c4b2be.png)

::: danger

字符串字面值是 C 风格的字符串，即 `char` 类型的数组，不应该该改变。也就是说，C 风格字符串的类型是 `const char[]`。但是，指针并没有反应出其所指向的内存区域是只读的这一点。这条语句并 **没有创建字符串字面值的可修改副本**，**只是存储了第一个字符的地址**。也就是说，如果尝试修改改字符串，就会出现问题

:::

为了反应出 C 风格字符串字面值是只读的，应该使用 `const char*` 类型的指针来存储字符串字面值的地址。例如

```cpp
const char *pproverb {"A miss is as good as a mile."};  // 推荐的做法
```

这条语句声明 `pproverb` 指针的类型是 `const char *` 类型，因为是 `const` 指针类型，所以能够与字符串字面值的类型保持一致。编译器也将阻止用这个指针对字符串字面值的字符进行赋值。关于 `const` 指针的更多内容将在后续章节中介绍。下面我们来看一个例子，在该例子中，使用 `const char *` 指针代替 `char[]` 数组

```cpp title="pointer_lucky_star.cpp"
import <iostream>;

int main()
{
    const char *pstar1 {"Fatty Arbuckle"};
    const char *pstar2 {"Clara Bow"};
    const char *pstar3 {"Lassie"};
    const char *pstar4 {"Slim Pickens"};
    const char *pstar5 {"Boris karloff"};
    const char *pstar6 {"Mae West"};
    const char *pstar7 {"Oliver Hardy"};
    const char *pstar8 {"Greta Garbo"};
    const char *pstr {"Your lucky star is "};
    std::cout << "Pick a lucky star! Enter a number between 1 and 8: ";
    size_t choice{};
    std::cin >> choice;

    switch (choice)
    {
        case 1: std::cout << pstr << pstar1 << ".\n"; break;
        case 2: std::cout << pstr << pstar2 << ".\n"; break;
        case 3: std::cout << pstr << pstar3 << ".\n"; break;
        case 4: std::cout << pstr << pstar4 << ".\n"; break;
        case 5: std::cout << pstr << pstar5 << ".\n"; break;
        case 6: std::cout << pstr << pstar6 << ".\n"; break;
        case 7: std::cout << pstr << pstar7 << ".\n"; break;
        case 8: std::cout << pstr << pstar8 << ".\n"; break;
        default: std::cout << "Sorry, you haven't got a lucky star." << std::endl;
    }
}
```

在该示例程序，我们使用了 $8$ 个相同类型的变量(`pstar1` 到 `pstar8`) 来存储明星的名字。如果使用数组来存储这些字符串，就需要定义一个二维数组，并指定每个字符串的最大长度，这样会浪费很多内存空间。使用指针变量来存储字符串字面值的地址，可以节省内存空间，并且代码更加简洁。

```cpp title="pointer_array_lucky_star.cpp"
import <iostream>;

int main()
{
    // 声明一个数组 pstars，其元素类型是 `const char *`
    const char* pstars[] {
        "Fatty Arbuckle",
        "Clara Bow",
        "Lassie",
        "Slim Pickens",
        "Boris karloff",
        "Mae West",
        "Oliver Hardy",
        "Greta Garbo"
        };

    std::cout << "Pick a lucky star! Enter a number between 1 and " << std::size(pstars) << ": ";
    size_t choice{};
    std::cin >> choice;

    if (choice >= 1 && choice < std::size(pstars))
    {
        std::cout << "Your lucky star is " << pstars[choice - 1] << ".\n";
    }
    else
    {
        std::cout << "Sorry, you haven't got a lucky star." << std::endl;
    }
    return 0;
}
```

这种用于存储指针的数组称为 **指针数组**。在上述例子中，`pstars` 是一个指针数组，其元素类型是 `const char*`。每个元素都存储了一个字符串字面值首字符的地址。通过这种方式，我们可以方便地管理多个字符串，并且节省内存空间。如下下图所示

![1763907514917-e291b1dc1a62c4928736acd44dfdeea8.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763907514917-e291b1dc1a62c4928736acd44dfdeea8.png)

## 常量指针和指向常量的指针

在上述例子中，通过 `const char *` 声明的数组，确保任何试图修改 `pstars` 数组元素指向的字符串的行为都会被编译器阻止：

```cpp
const char *pstars[] {
    "Fatty Arbuckle",
    "Clara Bow",
    "Lassie",
    "Slim Pickens",
    "Boris karloff",
    "Mae West",
    "Oliver Hardy",
    "Greta Garbo"
};
```

在这个声明中，把由 `pstars` 数组的元素指向的 `char` 元素指定为常量。由于编译器会阻止对该对象的直接修改，因此下面的语句会标识为错误，防止在运行时期间出现问题

```cpp
*pstars[0] = 'X';  // 错误：试图修改常量数据
```

但是，可以合法的编写下面语句，把存储在等号右边的元素中的地址复制到等号左边的元素中

```cpp
pstars[5] = pstars[6];  // 合法：修改指针，使其指向不同的地址
```

现在，这些 `pstars[5]` 和 `pstars[6]` 都指向 `"Oliver Hardy"` 字符串字面值。原本的 `pstars[5]` 指向的 `"Mae West"` 字符串字面值仍然存在于内存中并且没有发生变化，但不再有指针指向它。因此，这没有违背 `const char *` 的约束。

如果希望指针本身也是常量，可以使用如下声明语句

```cpp
const char * const pstars[]{
    "Fatty Arbuckle",
    "Clara Bow",
    "Lassie",
    "Slim Pickens",
    "Boris karloff",
    "Mae West",
    "Oliver Hardy",
    "Greta Garbo"
}
```

额外的 `const` 关键字和后面的元素类型规范把元素定义为常量，现在指针及其指向的字符串都被定义为常量。这样，这个数组现在不能修改

上面的声明是通过数组来介绍的，这可能有一点复杂，难以理解。现在，我们使用一个基本类型的非数组变量再次回顾 **指向常量的指针** 和 **常量指针** 的概念。例如

```cpp
const char * star {"Lassie"};  // 指向常量的指针
```

这里定义了一个包含 `const char` 元素的数组，意味着编译器不允许将 `"Lassie"` 字符串字面值中的任何字符修改为其他字符

```cpp
star[1] = 'o';  // 错误：试图修改常量数据
```

但是，`star` 的定义并不阻止将 `star` 指向其他字符串字面值。这是因为 `star` 变量本身不是常量。换句话说，只要使用一个指向 `const char` 元素的指针，就可以修改 `star` 变量的值

```cpp
star = "Mae West";  // 合法：修改指针，使其指向不同的地址
star = pstars[1];  // 合法：修改指针，使其指向不同的地址
```

如果想禁止这种赋值，需要再添加一个 `const` 关键字来保护 `star` 变量本身

```cpp
const char * const star {"Lassie"};  // 指向常量的常量指针
```

::: tip

总结一下，对指针及其指向的内容使用 `const` 有一下三种情况

---

**指向常量的指针**：指针指向的内容是常量，即不能通过指针修改其指向的内容。但是，**可以修改指针，指向其他的常量**

```cpp
const char *pstring {"Some text that cannot be changed."};  // 指向常量的指针
```

当然，这也适用于其他类型的指针

```cpp
const int value {20};
const int *pvalue {&value};
```

`value` 是一个常量，不能修改。`pvalue` 是一个指向常量的指针，可以用于存储 `value` 的地址。不能在非 `const int` 指针中存储 `value` 的地址。但是，可以把非 `const` 变量的地址赋值给 `pvalue`。换句话说，**可以加强常量的不变性，但是不能减弱它**

---

**常量指针**：存储在指针中的地址不能改变，即指针本身是常量。但是，**可以通过指针修改其指向的内容**

```cpp
int data[20];
int *const pdata {&data};  // 常量指针
```

这条语句声明 `pdata` 是常量指针，指向 `data`。使它指向另一个变量的任何尝试都是错误的。但是，可以通过 `pdata` 修改 `data` 数组中的内容

```cpp
*pdata = 25;  // 允许的：指针指向的内容不是常量
```

如果将 `data` 声明为常量，就不能用 `&data` 初始化 `pdata`，指针 `pdata` 只能指向 `int` 类型的非 `const` 变量

---

**指向常量的常量指针**：因为存储在指针中的地址和指针指向的内容都可以被声明为常量，所以两者都不能修改。例如

```cpp
const float value {3.14f};
```

现在，`value` 是一个常量，不能修改。但仍然可以用 `value` 的地址来初始化一个指针

```cpp
const float * const pvalue {&value};  // 指向常量的常量指针
```

`pvalue` 现在是一个指向常量的常量指针，既不能修改 `pvalue` 指向的地址，也不能通过 `pvalue` 修改其指向的内容

:::
